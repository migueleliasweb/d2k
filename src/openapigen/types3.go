// Package openapigen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version (devel) DO NOT EDIT.
package openapigen

import (
	"encoding/json"
	"fmt"
	"time"
)

// Defines values for ContainerStateStatus.
const (
	ContainerStateStatusCreated ContainerStateStatus = "created"

	ContainerStateStatusDead ContainerStateStatus = "dead"

	ContainerStateStatusExited ContainerStateStatus = "exited"

	ContainerStateStatusPaused ContainerStateStatus = "paused"

	ContainerStateStatusRemoving ContainerStateStatus = "removing"

	ContainerStateStatusRestarting ContainerStateStatus = "restarting"

	ContainerStateStatusRunning ContainerStateStatus = "running"
)

// Defines values for EndpointPortConfigProtocol.
const (
	EndpointPortConfigProtocolSctp EndpointPortConfigProtocol = "sctp"

	EndpointPortConfigProtocolTcp EndpointPortConfigProtocol = "tcp"

	EndpointPortConfigProtocolUdp EndpointPortConfigProtocol = "udp"
)

// Defines values for EndpointPortConfigPublishMode.
const (
	EndpointPortConfigPublishModeHost EndpointPortConfigPublishMode = "host"

	EndpointPortConfigPublishModeIngress EndpointPortConfigPublishMode = "ingress"
)

// Defines values for EndpointSpecMode.
const (
	EndpointSpecModeDnsrr EndpointSpecMode = "dnsrr"

	EndpointSpecModeVip EndpointSpecMode = "vip"
)

// Defines values for HealthStatus.
const (
	HealthStatusHealthy HealthStatus = "healthy"

	HealthStatusNone HealthStatus = "none"

	HealthStatusStarting HealthStatus = "starting"

	HealthStatusUnhealthy HealthStatus = "unhealthy"
)

// Defines values for HostConfigCgroupnsMode.
const (
	HostConfigCgroupnsModeHost HostConfigCgroupnsMode = "host"

	HostConfigCgroupnsModePrivate HostConfigCgroupnsMode = "private"
)

// Defines values for HostConfigIsolation.
const (
	HostConfigIsolationDefault HostConfigIsolation = "default"

	HostConfigIsolationHyperv HostConfigIsolation = "hyperv"

	HostConfigIsolationProcess HostConfigIsolation = "process"
)

// Defines values for HostConfigLogConfigType.
const (
	HostConfigLogConfigTypeAwslogs HostConfigLogConfigType = "awslogs"

	HostConfigLogConfigTypeEtwlogs HostConfigLogConfigType = "etwlogs"

	HostConfigLogConfigTypeFluentd HostConfigLogConfigType = "fluentd"

	HostConfigLogConfigTypeGelf HostConfigLogConfigType = "gelf"

	HostConfigLogConfigTypeJournald HostConfigLogConfigType = "journald"

	HostConfigLogConfigTypeJsonFile HostConfigLogConfigType = "json-file"

	HostConfigLogConfigTypeNone HostConfigLogConfigType = "none"

	HostConfigLogConfigTypeSplunk HostConfigLogConfigType = "splunk"

	HostConfigLogConfigTypeSyslog HostConfigLogConfigType = "syslog"
)

// Defines values for LocalNodeState.
const (
	LocalNodeStateActive LocalNodeState = "active"

	LocalNodeStateEmpty LocalNodeState = ""

	LocalNodeStateError LocalNodeState = "error"

	LocalNodeStateInactive LocalNodeState = "inactive"

	LocalNodeStateLocked LocalNodeState = "locked"

	LocalNodeStatePending LocalNodeState = "pending"
)

// Defines values for MountBindOptionsPropagation.
const (
	MountBindOptionsPropagationPrivate MountBindOptionsPropagation = "private"

	MountBindOptionsPropagationRprivate MountBindOptionsPropagation = "rprivate"

	MountBindOptionsPropagationRshared MountBindOptionsPropagation = "rshared"

	MountBindOptionsPropagationRslave MountBindOptionsPropagation = "rslave"

	MountBindOptionsPropagationShared MountBindOptionsPropagation = "shared"

	MountBindOptionsPropagationSlave MountBindOptionsPropagation = "slave"
)

// Defines values for MountType.
const (
	MountTypeBind MountType = "bind"

	MountTypeNpipe MountType = "npipe"

	MountTypeTmpfs MountType = "tmpfs"

	MountTypeVolume MountType = "volume"
)

// Defines values for NodeSpecAvailability.
const (
	NodeSpecAvailabilityActive NodeSpecAvailability = "active"

	NodeSpecAvailabilityDrain NodeSpecAvailability = "drain"

	NodeSpecAvailabilityPause NodeSpecAvailability = "pause"
)

// Defines values for NodeSpecRole.
const (
	NodeSpecRoleManager NodeSpecRole = "manager"

	NodeSpecRoleWorker NodeSpecRole = "worker"
)

// Defines values for NodeState.
const (
	NodeStateDisconnected NodeState = "disconnected"

	NodeStateDown NodeState = "down"

	NodeStateReady NodeState = "ready"

	NodeStateUnknown NodeState = "unknown"
)

// Defines values for PluginConfigInterfaceProtocolScheme.
const (
	PluginConfigInterfaceProtocolSchemeEmpty PluginConfigInterfaceProtocolScheme = ""

	PluginConfigInterfaceProtocolSchemeMobyPluginsHttpv1 PluginConfigInterfaceProtocolScheme = "moby.plugins.http/v1"
)

// Defines values for PortType.
const (
	PortTypeSctp PortType = "sctp"

	PortTypeTcp PortType = "tcp"

	PortTypeUdp PortType = "udp"
)

// Defines values for Reachability.
const (
	ReachabilityReachable Reachability = "reachable"

	ReachabilityUnknown Reachability = "unknown"

	ReachabilityUnreachable Reachability = "unreachable"
)

// Defines values for RestartPolicyName.
const (
	RestartPolicyNameAlways RestartPolicyName = "always"

	RestartPolicyNameEmpty RestartPolicyName = ""

	RestartPolicyNameOnFailure RestartPolicyName = "on-failure"

	RestartPolicyNameUnlessStopped RestartPolicyName = "unless-stopped"
)

// Defines values for ServiceUpdateStatusState.
const (
	ServiceUpdateStatusStateCompleted ServiceUpdateStatusState = "completed"

	ServiceUpdateStatusStatePaused ServiceUpdateStatusState = "paused"

	ServiceUpdateStatusStateUpdating ServiceUpdateStatusState = "updating"
)

// Defines values for ServiceSpecRollbackConfigFailureAction.
const (
	ServiceSpecRollbackConfigFailureActionContinue ServiceSpecRollbackConfigFailureAction = "continue"

	ServiceSpecRollbackConfigFailureActionPause ServiceSpecRollbackConfigFailureAction = "pause"
)

// Defines values for ServiceSpecRollbackConfigOrder.
const (
	ServiceSpecRollbackConfigOrderStartFirst ServiceSpecRollbackConfigOrder = "start-first"

	ServiceSpecRollbackConfigOrderStopFirst ServiceSpecRollbackConfigOrder = "stop-first"
)

// Defines values for ServiceSpecUpdateConfigFailureAction.
const (
	ServiceSpecUpdateConfigFailureActionContinue ServiceSpecUpdateConfigFailureAction = "continue"

	ServiceSpecUpdateConfigFailureActionPause ServiceSpecUpdateConfigFailureAction = "pause"

	ServiceSpecUpdateConfigFailureActionRollback ServiceSpecUpdateConfigFailureAction = "rollback"
)

// Defines values for ServiceSpecUpdateConfigOrder.
const (
	ServiceSpecUpdateConfigOrderStartFirst ServiceSpecUpdateConfigOrder = "start-first"

	ServiceSpecUpdateConfigOrderStopFirst ServiceSpecUpdateConfigOrder = "stop-first"
)

// Defines values for SwarmSpecCAConfigExternalCAsProtocol.
const (
	SwarmSpecCAConfigExternalCAsProtocolCfssl SwarmSpecCAConfigExternalCAsProtocol = "cfssl"
)

// Defines values for SystemInfoCgroupDriver.
const (
	SystemInfoCgroupDriverCgroupfs SystemInfoCgroupDriver = "cgroupfs"

	SystemInfoCgroupDriverNone SystemInfoCgroupDriver = "none"

	SystemInfoCgroupDriverSystemd SystemInfoCgroupDriver = "systemd"
)

// Defines values for SystemInfoCgroupVersion.
const (
	SystemInfoCgroupVersionN1 SystemInfoCgroupVersion = "1"

	SystemInfoCgroupVersionN2 SystemInfoCgroupVersion = "2"
)

// Defines values for SystemInfoIsolation.
const (
	SystemInfoIsolationDefault SystemInfoIsolation = "default"

	SystemInfoIsolationHyperv SystemInfoIsolation = "hyperv"

	SystemInfoIsolationProcess SystemInfoIsolation = "process"
)

// Defines values for TaskSpecContainerSpecIsolation.
const (
	TaskSpecContainerSpecIsolationDefault TaskSpecContainerSpecIsolation = "default"

	TaskSpecContainerSpecIsolationHyperv TaskSpecContainerSpecIsolation = "hyperv"

	TaskSpecContainerSpecIsolationProcess TaskSpecContainerSpecIsolation = "process"
)

// Defines values for TaskSpecRestartPolicyCondition.
const (
	TaskSpecRestartPolicyConditionAny TaskSpecRestartPolicyCondition = "any"

	TaskSpecRestartPolicyConditionNone TaskSpecRestartPolicyCondition = "none"

	TaskSpecRestartPolicyConditionOnFailure TaskSpecRestartPolicyCondition = "on-failure"
)

// Defines values for TaskState.
const (
	TaskStateAccepted TaskState = "accepted"

	TaskStateAllocated TaskState = "allocated"

	TaskStateAssigned TaskState = "assigned"

	TaskStateComplete TaskState = "complete"

	TaskStateFailed TaskState = "failed"

	TaskStateNew TaskState = "new"

	TaskStateOrphaned TaskState = "orphaned"

	TaskStatePending TaskState = "pending"

	TaskStatePreparing TaskState = "preparing"

	TaskStateReady TaskState = "ready"

	TaskStateRejected TaskState = "rejected"

	TaskStateRemove TaskState = "remove"

	TaskStateRunning TaskState = "running"

	TaskStateShutdown TaskState = "shutdown"

	TaskStateStarting TaskState = "starting"
)

// Defines values for VolumeScope.
const (
	VolumeScopeGlobal VolumeScope = "global"

	VolumeScopeLocal VolumeScope = "local"
)

// Address represents an IPv4 or IPv6 IP address.
type Address struct {
	// IP address.
	Addr *string `json:"Addr,omitempty"`

	// Mask length of the IP address.
	PrefixLen *int `json:"PrefixLen,omitempty"`
}

// AuthConfig defines model for AuthConfig.
type AuthConfig struct {
	Email         *string `json:"email,omitempty"`
	Password      *string `json:"password,omitempty"`
	Serveraddress *string `json:"serveraddress,omitempty"`
	Username      *string `json:"username,omitempty"`
}

// BuildCache defines model for BuildCache.
type BuildCache struct {
	// Date and time at which the build cache was created in
	// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
	CreatedAt   *string `json:"CreatedAt,omitempty"`
	Description *string `json:"Description,omitempty"`
	ID          *string `json:"ID,omitempty"`
	InUse       *bool   `json:"InUse,omitempty"`

	// Date and time at which the build cache was last used in
	// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
	LastUsedAt *string `json:"LastUsedAt"`
	Parent     *string `json:"Parent,omitempty"`
	Shared     *bool   `json:"Shared,omitempty"`

	// Amount of disk space used by the build cache (in bytes).
	Size       *int    `json:"Size,omitempty"`
	Type       *string `json:"Type,omitempty"`
	UsageCount *int    `json:"UsageCount,omitempty"`
}

// ClusterInfo represents information about the swarm as is returned by the
// "/info" endpoint. Join-tokens are not included.
type ClusterInfo struct {
	// Date and time at which the swarm was initialised in
	// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
	CreatedAt *string `json:"CreatedAt,omitempty"`

	// DataPathPort specifies the data path port number for data traffic.
	// Acceptable port range is 1024 to 49151.
	// If no port is set or is set to 0, the default port (4789) is used.
	DataPathPort *uint32 `json:"DataPathPort,omitempty"`

	// Default Address Pool specifies default subnet pools for global scope
	// networks.
	DefaultAddrPool *[]string `json:"DefaultAddrPool,omitempty"`

	// The ID of the swarm.
	ID *string `json:"ID,omitempty"`

	// Whether there is currently a root CA rotation in progress for the swarm
	RootRotationInProgress *bool `json:"RootRotationInProgress,omitempty"`

	// User modifiable swarm configuration.
	Spec *SwarmSpec `json:"Spec,omitempty"`

	// SubnetSize specifies the subnet size of the networks created from the
	// default subnet pool.
	SubnetSize *uint32 `json:"SubnetSize,omitempty"`

	// Information about the issuer of leaf TLS certificates and the trusted root
	// CA certificate.
	TLSInfo *TLSInfo `json:"TLSInfo,omitempty"`

	// Date and time at which the swarm was last updated in
	// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
	UpdatedAt *string `json:"UpdatedAt,omitempty"`

	// The version number of the object such as node, service, etc. This is needed
	// to avoid conflicting writes. The client must send the version number along
	// with the modified specification when updating these objects.
	//
	// This approach ensures safe concurrency and determinism in that the change
	// on the object may not be applied if the version number has changed from the
	// last read. In other words, if two update requests specify the same base
	// version, only one of the requests can succeed. As a result, two separate
	// update requests that happen at the same time will not unintentionally
	// overwrite each other.
	Version *ObjectVersion `json:"Version,omitempty"`
}

// Commit holds the Git-commit (SHA1) that a binary was built from, as
// reported in the version-string of external tools, such as `containerd`,
// or `runC`.
type Commit struct {
	// Commit ID of external tool expected by dockerd as set at build time.
	Expected *string `json:"Expected,omitempty"`

	// Actual commit ID of external tool.
	ID *string `json:"ID,omitempty"`
}

// Config defines model for Config.
type Config struct {
	CreatedAt *string     `json:"CreatedAt,omitempty"`
	ID        *string     `json:"ID,omitempty"`
	Spec      *ConfigSpec `json:"Spec,omitempty"`
	UpdatedAt *string     `json:"UpdatedAt,omitempty"`

	// The version number of the object such as node, service, etc. This is needed
	// to avoid conflicting writes. The client must send the version number along
	// with the modified specification when updating these objects.
	//
	// This approach ensures safe concurrency and determinism in that the change
	// on the object may not be applied if the version number has changed from the
	// last read. In other words, if two update requests specify the same base
	// version, only one of the requests can succeed. As a result, two separate
	// update requests that happen at the same time will not unintentionally
	// overwrite each other.
	Version *ObjectVersion `json:"Version,omitempty"`
}

// ConfigSpec defines model for ConfigSpec.
type ConfigSpec struct {
	// Base64-url-safe-encoded ([RFC 4648](https://tools.ietf.org/html/rfc4648#section-5))
	// config data.
	Data *string `json:"Data,omitempty"`

	// User-defined key/value metadata.
	Labels *ConfigSpec_Labels `json:"Labels,omitempty"`

	// User-defined name of the config.
	Name *string `json:"Name,omitempty"`

	// Driver represents a driver (network, logging, secrets).
	Templating *Driver `json:"Templating,omitempty"`
}

// User-defined key/value metadata.
type ConfigSpec_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Configuration for a container that is portable between hosts
type ContainerConfig struct {
	// Command is already escaped (Windows only)
	ArgsEscaped *bool `json:"ArgsEscaped,omitempty"`

	// Whether to attach to `stderr`.
	AttachStderr *bool `json:"AttachStderr,omitempty"`

	// Whether to attach to `stdin`.
	AttachStdin *bool `json:"AttachStdin,omitempty"`

	// Whether to attach to `stdout`.
	AttachStdout *bool `json:"AttachStdout,omitempty"`

	// Command to run specified as a string or an array of strings.
	Cmd *[]string `json:"Cmd,omitempty"`

	// The domain name to use for the container.
	Domainname *string `json:"Domainname,omitempty"`

	// The entry point for the container as a string or an array of strings.
	//
	// If the array consists of exactly one empty string (`[""]`) then the
	// entry point is reset to system default (i.e., the entry point used by
	// docker when there is no `ENTRYPOINT` instruction in the `Dockerfile`).
	Entrypoint *[]string `json:"Entrypoint,omitempty"`

	// A list of environment variables to set inside the container in the
	// form `["VAR=value", ...]`. A variable without `=` is removed from the
	// environment, rather than to have an empty value.
	Env *[]string `json:"Env,omitempty"`

	// An object mapping ports to an empty object in the form:
	//
	// `{"<port>/<tcp|udp|sctp>": {}}`
	ExposedPorts *ContainerConfig_ExposedPorts `json:"ExposedPorts,omitempty"`

	// A test to perform to check that the container is healthy.
	Healthcheck *HealthConfig `json:"Healthcheck,omitempty"`

	// The hostname to use for the container, as a valid RFC 1123 hostname.
	Hostname *string `json:"Hostname,omitempty"`

	// The name of the image to use when creating the container/
	Image *string `json:"Image,omitempty"`

	// User-defined key/value metadata.
	Labels *ContainerConfig_Labels `json:"Labels,omitempty"`

	// MAC address of the container.
	MacAddress *string `json:"MacAddress,omitempty"`

	// Disable networking for the container.
	NetworkDisabled *bool `json:"NetworkDisabled,omitempty"`

	// `ONBUILD` metadata that were defined in the image's `Dockerfile`.
	OnBuild *[]string `json:"OnBuild,omitempty"`

	// Open `stdin`
	OpenStdin *bool `json:"OpenStdin,omitempty"`

	// Shell for when `RUN`, `CMD`, and `ENTRYPOINT` uses a shell.
	Shell *[]string `json:"Shell,omitempty"`

	// Close `stdin` after one attached client disconnects
	StdinOnce *bool `json:"StdinOnce,omitempty"`

	// Signal to stop a container as a string or unsigned integer.
	StopSignal *string `json:"StopSignal,omitempty"`

	// Timeout to stop a container in seconds.
	StopTimeout *int `json:"StopTimeout,omitempty"`

	// Attach standard streams to a TTY, including `stdin` if it is not closed.
	Tty *bool `json:"Tty,omitempty"`

	// The user that commands are run as inside the container.
	User *string `json:"User,omitempty"`

	// An object mapping mount point paths inside the container to empty
	// objects.
	Volumes *ContainerConfig_Volumes `json:"Volumes,omitempty"`

	// The working directory for commands to run in.
	WorkingDir *string `json:"WorkingDir,omitempty"`
}

// An object mapping ports to an empty object in the form:
//
// `{"<port>/<tcp|udp|sctp>": {}}`
type ContainerConfig_ExposedPorts struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// User-defined key/value metadata.
type ContainerConfig_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// An object mapping mount point paths inside the container to empty
// objects.
type ContainerConfig_Volumes struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// ContainerState stores container's running state. It's part of ContainerJSONBase
// and will be returned by the "inspect" command.
type ContainerState struct {
	Dead  *bool   `json:"Dead,omitempty"`
	Error *string `json:"Error,omitempty"`

	// The last exit code of this container
	ExitCode *int `json:"ExitCode,omitempty"`

	// The time when this container last exited.
	FinishedAt *string `json:"FinishedAt,omitempty"`

	// Health stores information about the container's healthcheck results.
	Health *Health `json:"Health,omitempty"`

	// Whether this container has been killed because it ran out of memory.
	OOMKilled *bool `json:"OOMKilled,omitempty"`

	// Whether this container is paused.
	Paused *bool `json:"Paused,omitempty"`

	// The process ID of this container
	Pid *int `json:"Pid,omitempty"`

	// Whether this container is restarting.
	Restarting *bool `json:"Restarting,omitempty"`

	// Whether this container is running.
	//
	// Note that a running container can be _paused_. The `Running` and `Paused`
	// booleans are not mutually exclusive:
	//
	// When pausing a container (on Linux), the freezer cgroup is used to suspend
	// all processes in the container. Freezing the process requires the process to
	// be running. As a result, paused containers are both `Running` _and_ `Paused`.
	//
	// Use the `Status` field instead to determine if a container's state is "running".
	Running *bool `json:"Running,omitempty"`

	// The time when this container was last started.
	StartedAt *string `json:"StartedAt,omitempty"`

	// String representation of the container state. Can be one of "created",
	// "running", "paused", "restarting", "removing", "exited", or "dead".
	Status *ContainerStateStatus `json:"Status,omitempty"`
}

// String representation of the container state. Can be one of "created",
// "running", "paused", "restarting", "removing", "exited", or "dead".
type ContainerStateStatus string

// ContainerSummary defines model for ContainerSummary.
type ContainerSummary []struct {
	// Command to run when starting the container
	Command *string `json:"Command,omitempty"`

	// When the container was created
	Created    *int64 `json:"Created,omitempty"`
	HostConfig *struct {
		NetworkMode *string `json:"NetworkMode,omitempty"`
	} `json:"HostConfig,omitempty"`

	// The ID of this container
	Id *string `json:"Id,omitempty"`

	// The name of the image used when creating this container
	Image *string `json:"Image,omitempty"`

	// The ID of the image that this container was created from
	ImageID *string `json:"ImageID,omitempty"`

	// User-defined key/value metadata.
	Labels *ContainerSummary_Labels `json:"Labels,omitempty"`
	Mounts *[]Mount                 `json:"Mounts,omitempty"`

	// The names that this container has been given
	Names *[]string `json:"Names,omitempty"`

	// A summary of the container's network settings
	NetworkSettings *struct {
		Networks *ContainerSummary_NetworkSettings_Networks `json:"Networks,omitempty"`
	} `json:"NetworkSettings,omitempty"`

	// The ports exposed by this container
	Ports *[]Port `json:"Ports,omitempty"`

	// The total size of all the files in this container
	SizeRootFs *int64 `json:"SizeRootFs,omitempty"`

	// The size of files that have been created or changed by this container
	SizeRw *int64 `json:"SizeRw,omitempty"`

	// The state of this container (e.g. `Exited`)
	State *string `json:"State,omitempty"`

	// Additional human-readable status of this container (e.g. `Exit 0`)
	Status *string `json:"Status,omitempty"`
}

// User-defined key/value metadata.
type ContainerSummary_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ContainerSummary_NetworkSettings_Networks defines model for ContainerSummary.NetworkSettings.Networks.
type ContainerSummary_NetworkSettings_Networks struct {
	AdditionalProperties map[string]EndpointSettings `json:"-"`
}

// A device mapping between the host and container
type DeviceMapping struct {
	CgroupPermissions *string `json:"CgroupPermissions,omitempty"`
	PathInContainer   *string `json:"PathInContainer,omitempty"`
	PathOnHost        *string `json:"PathOnHost,omitempty"`
}

// A request for devices to be sent to device drivers
type DeviceRequest struct {
	// A list of capabilities; an OR list of AND lists of capabilities.
	Capabilities *[][]string `json:"Capabilities,omitempty"`
	Count        *int        `json:"Count,omitempty"`
	DeviceIDs    *[]string   `json:"DeviceIDs,omitempty"`
	Driver       *string     `json:"Driver,omitempty"`

	// Driver-specific options, specified as a key/value pairs. These options
	// are passed directly to the driver.
	Options *DeviceRequest_Options `json:"Options,omitempty"`
}

// Driver-specific options, specified as a key/value pairs. These options
// are passed directly to the driver.
type DeviceRequest_Options struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Driver represents a driver (network, logging, secrets).
type Driver struct {
	// Name of the driver.
	Name string `json:"Name"`

	// Key/value map of driver-specific options.
	Options *Driver_Options `json:"Options,omitempty"`
}

// Key/value map of driver-specific options.
type Driver_Options struct {
	AdditionalProperties map[string]string `json:"-"`
}

// EndpointIPAMConfig represents an endpoint's IPAM configuration.
type EndpointIPAMConfig struct {
	IPv4Address  *string   `json:"IPv4Address,omitempty"`
	IPv6Address  *string   `json:"IPv6Address,omitempty"`
	LinkLocalIPs *[]string `json:"LinkLocalIPs,omitempty"`
}

// EndpointPortConfig defines model for EndpointPortConfig.
type EndpointPortConfig struct {
	Name     *string                     `json:"Name,omitempty"`
	Protocol *EndpointPortConfigProtocol `json:"Protocol,omitempty"`

	// The mode in which port is published.
	//
	// <p><br /></p>
	//
	// - "ingress" makes the target port accessible on every node,
	//   regardless of whether there is a task for the service running on
	//   that node or not.
	// - "host" bypasses the routing mesh and publish the port directly on
	//   the swarm node where that service is running.
	PublishMode *EndpointPortConfigPublishMode `json:"PublishMode,omitempty"`

	// The port on the swarm hosts.
	PublishedPort *int `json:"PublishedPort,omitempty"`

	// The port inside the container.
	TargetPort *int `json:"TargetPort,omitempty"`
}

// EndpointPortConfigProtocol defines model for EndpointPortConfig.Protocol.
type EndpointPortConfigProtocol string

// The mode in which port is published.
//
// <p><br /></p>
//
// - "ingress" makes the target port accessible on every node,
//   regardless of whether there is a task for the service running on
//   that node or not.
// - "host" bypasses the routing mesh and publish the port directly on
//   the swarm node where that service is running.
type EndpointPortConfigPublishMode string

// Configuration for a network endpoint.
type EndpointSettings struct {
	Aliases *[]string `json:"Aliases,omitempty"`

	// DriverOpts is a mapping of driver options and values. These options
	// are passed directly to the driver and are driver specific.
	DriverOpts *EndpointSettings_DriverOpts `json:"DriverOpts"`

	// Unique ID for the service endpoint in a Sandbox.
	EndpointID *string `json:"EndpointID,omitempty"`

	// Gateway address for this network.
	Gateway *string `json:"Gateway,omitempty"`

	// Global IPv6 address.
	GlobalIPv6Address *string `json:"GlobalIPv6Address,omitempty"`

	// Mask length of the global IPv6 address.
	GlobalIPv6PrefixLen *int64 `json:"GlobalIPv6PrefixLen,omitempty"`

	// EndpointIPAMConfig represents an endpoint's IPAM configuration.
	IPAMConfig *EndpointIPAMConfig `json:"IPAMConfig"`

	// IPv4 address.
	IPAddress *string `json:"IPAddress,omitempty"`

	// Mask length of the IPv4 address.
	IPPrefixLen *int `json:"IPPrefixLen,omitempty"`

	// IPv6 gateway address.
	IPv6Gateway *string   `json:"IPv6Gateway,omitempty"`
	Links       *[]string `json:"Links,omitempty"`

	// MAC address for the endpoint on this network.
	MacAddress *string `json:"MacAddress,omitempty"`

	// Unique ID of the network.
	NetworkID *string `json:"NetworkID,omitempty"`
}

// DriverOpts is a mapping of driver options and values. These options
// are passed directly to the driver and are driver specific.
type EndpointSettings_DriverOpts struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Properties that can be configured to access and load balance a service.
type EndpointSpec struct {
	// The mode of resolution to use for internal load balancing between tasks.
	Mode *EndpointSpecMode `json:"Mode,omitempty"`

	// List of exposed ports that this service is accessible on from the
	// outside. Ports can only be provided if `vip` resolution mode is used.
	Ports *[]EndpointPortConfig `json:"Ports,omitempty"`
}

// The mode of resolution to use for internal load balancing between tasks.
type EndpointSpecMode string

// EngineDescription provides information about an engine.
type EngineDescription struct {
	EngineVersion *string                   `json:"EngineVersion,omitempty"`
	Labels        *EngineDescription_Labels `json:"Labels,omitempty"`
	Plugins       *[]struct {
		Name *string `json:"Name,omitempty"`
		Type *string `json:"Type,omitempty"`
	} `json:"Plugins,omitempty"`
}

// EngineDescription_Labels defines model for EngineDescription.Labels.
type EngineDescription_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Represents an error.
type ErrorResponse struct {
	// The error message.
	Message string `json:"message"`
}

// User-defined resources can be either Integer resources (e.g, `SSD=3`) or
// String resources (e.g, `GPU=UUID1`).
type GenericResources []struct {
	DiscreteResourceSpec *struct {
		Kind  *string `json:"Kind,omitempty"`
		Value *int64  `json:"Value,omitempty"`
	} `json:"DiscreteResourceSpec,omitempty"`
	NamedResourceSpec *struct {
		Kind  *string `json:"Kind,omitempty"`
		Value *string `json:"Value,omitempty"`
	} `json:"NamedResourceSpec,omitempty"`
}

// Information about a container's graph driver.
type GraphDriverData struct {
	Data GraphDriverData_Data `json:"Data"`
	Name string               `json:"Name"`
}

// GraphDriverData_Data defines model for GraphDriverData.Data.
type GraphDriverData_Data struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Health stores information about the container's healthcheck results.
type Health struct {
	// FailingStreak is the number of consecutive failures
	FailingStreak *int `json:"FailingStreak,omitempty"`

	// Log contains the last few results (oldest first)
	Log *[]HealthcheckResult `json:"Log,omitempty"`

	// Status is one of `none`, `starting`, `healthy` or `unhealthy`
	//
	// - "none"      Indicates there is no healthcheck
	// - "starting"  Starting indicates that the container is not yet ready
	// - "healthy"   Healthy indicates that the container is running correctly
	// - "unhealthy" Unhealthy indicates that the container has a problem
	Status *HealthStatus `json:"Status,omitempty"`
}

// Status is one of `none`, `starting`, `healthy` or `unhealthy`
//
// - "none"      Indicates there is no healthcheck
// - "starting"  Starting indicates that the container is not yet ready
// - "healthy"   Healthy indicates that the container is running correctly
// - "unhealthy" Unhealthy indicates that the container has a problem
type HealthStatus string

// A test to perform to check that the container is healthy.
type HealthConfig struct {
	// The time to wait between checks in nanoseconds. It should be 0 or at
	// least 1000000 (1 ms). 0 means inherit.
	Interval *int `json:"Interval,omitempty"`

	// The number of consecutive failures needed to consider a container as
	// unhealthy. 0 means inherit.
	Retries *int `json:"Retries,omitempty"`

	// Start period for the container to initialize before starting
	// health-retries countdown in nanoseconds. It should be 0 or at least
	// 1000000 (1 ms). 0 means inherit.
	StartPeriod *int `json:"StartPeriod,omitempty"`

	// The test to perform. Possible values are:
	//
	// - `[]` inherit healthcheck from image or parent image
	// - `["NONE"]` disable healthcheck
	// - `["CMD", args...]` exec arguments directly
	// - `["CMD-SHELL", command]` run command with system's default shell
	Test *[]string `json:"Test,omitempty"`

	// The time to wait before considering the check to have hung. It should
	// be 0 or at least 1000000 (1 ms). 0 means inherit.
	Timeout *int `json:"Timeout,omitempty"`
}

// HealthcheckResult stores information about a single run of a healthcheck probe
type HealthcheckResult struct {
	// Date and time at which this check ended in
	// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
	End *string `json:"End,omitempty"`

	// ExitCode meanings:
	//
	// - `0` healthy
	// - `1` unhealthy
	// - `2` reserved (considered unhealthy)
	// - other values: error running probe
	ExitCode *int `json:"ExitCode,omitempty"`

	// Output from last check
	Output *string `json:"Output,omitempty"`

	// Date and time at which this check started in
	// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
	Start *time.Time `json:"Start,omitempty"`
}

// HostConfig defines model for HostConfig.
type HostConfig struct {
	// Embedded struct due to allOf(#/components/schemas/Resources)
	Resources `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// Automatically remove the container when the container's process
	// exits. This has no effect if `RestartPolicy` is set.
	AutoRemove *bool `json:"AutoRemove,omitempty"`

	// A list of volume bindings for this container. Each volume binding
	// is a string in one of these forms:
	//
	// - `host-src:container-dest[:options]` to bind-mount a host path
	//   into the container. Both `host-src`, and `container-dest` must
	//   be an _absolute_ path.
	// - `volume-name:container-dest[:options]` to bind-mount a volume
	//   managed by a volume driver into the container. `container-dest`
	//   must be an _absolute_ path.
	//
	// `options` is an optional, comma-delimited list of:
	//
	// - `nocopy` disables automatic copying of data from the container
	//   path to the volume. The `nocopy` flag only applies to named volumes.
	// - `[ro|rw]` mounts a volume read-only or read-write, respectively.
	//   If omitted or set to `rw`, volumes are mounted read-write.
	// - `[z|Z]` applies SELinux labels to allow or deny multiple containers
	//   to read and write to the same volume.
	//     - `z`: a _shared_ content label is applied to the content. This
	//       label indicates that multiple containers can share the volume
	//       content, for both reading and writing.
	//     - `Z`: a _private unshared_ label is applied to the content.
	//       This label indicates that only the current container can use
	//       a private volume. Labeling systems such as SELinux require
	//       proper labels to be placed on volume content that is mounted
	//       into a container. Without a label, the security system can
	//       prevent a container's processes from using the content. By
	//       default, the labels set by the host operating system are not
	//       modified.
	// - `[[r]shared|[r]slave|[r]private]` specifies mount
	//   [propagation behavior](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt).
	//   This only applies to bind-mounted volumes, not internal volumes
	//   or named volumes. Mount propagation requires the source mount
	//   point (the location where the source directory is mounted in the
	//   host operating system) to have the correct propagation properties.
	//   For shared volumes, the source mount point must be set to `shared`.
	//   For slave volumes, the mount must be set to either `shared` or
	//   `slave`.
	Binds *[]string `json:"Binds,omitempty"`

	// A list of kernel capabilities to add to the container. Conflicts
	// with option 'Capabilities'.
	CapAdd *[]string `json:"CapAdd,omitempty"`

	// A list of kernel capabilities to drop from the container. Conflicts
	// with option 'Capabilities'.
	CapDrop *[]string `json:"CapDrop,omitempty"`

	// Cgroup to use for the container.
	Cgroup *string `json:"Cgroup,omitempty"`

	// cgroup namespace mode for the container. Possible values are:
	//
	// - `"private"`: the container runs in its own private cgroup namespace
	// - `"host"`: use the host system's cgroup namespace
	//
	// If not specified, the daemon default is used, which can either be `"private"`
	// or `"host"`, depending on daemon version, kernel support and configuration.
	CgroupnsMode *HostConfigCgroupnsMode `json:"CgroupnsMode,omitempty"`

	// Initial console size, as an `[height, width]` array. (Windows only)
	ConsoleSize *[]int `json:"ConsoleSize,omitempty"`

	// Path to a file where the container ID is written
	ContainerIDFile *string `json:"ContainerIDFile,omitempty"`

	// A list of DNS servers for the container to use.
	Dns *[]string `json:"Dns,omitempty"`

	// A list of DNS options.
	DnsOptions *[]string `json:"DnsOptions,omitempty"`

	// A list of DNS search domains.
	DnsSearch *[]string `json:"DnsSearch,omitempty"`

	// A list of hostnames/IP mappings to add to the container's `/etc/hosts`
	// file. Specified in the form `["hostname:IP"]`.
	ExtraHosts *[]string `json:"ExtraHosts,omitempty"`

	// A list of additional groups that the container process will run as.
	GroupAdd *[]string `json:"GroupAdd,omitempty"`

	// IPC sharing mode for the container. Possible values are:
	//
	// - `"none"`: own private IPC namespace, with /dev/shm not mounted
	// - `"private"`: own private IPC namespace
	// - `"shareable"`: own private IPC namespace, with a possibility to share it with other containers
	// - `"container:<name|id>"`: join another (shareable) container's IPC namespace
	// - `"host"`: use the host system's IPC namespace
	//
	// If not specified, daemon default is used, which can either be `"private"`
	// or `"shareable"`, depending on daemon version and configuration.
	IpcMode *string `json:"IpcMode,omitempty"`

	// Isolation technology of the container. (Windows only)
	Isolation *HostConfigIsolation `json:"Isolation,omitempty"`

	// A list of links for the container in the form `container_name:alias`.
	Links *[]string `json:"Links,omitempty"`

	// The logging configuration for this container
	LogConfig *struct {
		Config *HostConfig_LogConfig_Config `json:"Config,omitempty"`
		Type   *HostConfigLogConfigType     `json:"Type,omitempty"`
	} `json:"LogConfig,omitempty"`

	// The list of paths to be masked inside the container (this overrides
	// the default set of paths).
	MaskedPaths *[]string `json:"MaskedPaths,omitempty"`

	// Specification for mounts to be added to the container.
	Mounts *[]Mount `json:"Mounts,omitempty"`

	// Network mode to use for this container. Supported standard values
	// are: `bridge`, `host`, `none`, and `container:<name|id>`. Any
	// other value is taken as a custom network's name to which this
	// container should connect to.
	NetworkMode *string `json:"NetworkMode,omitempty"`

	// An integer value containing the score given to the container in
	// order to tune OOM killer preferences.
	OomScoreAdj *int `json:"OomScoreAdj,omitempty"`

	// Set the PID (Process) Namespace mode for the container. It can be
	// either:
	//
	// - `"container:<name|id>"`: joins another container's PID namespace
	// - `"host"`: use the host's PID namespace inside the container
	PidMode *string `json:"PidMode,omitempty"`

	// PortMap describes the mapping of container ports to host ports, using the
	// container's port-number and protocol as key in the format `<port>/<protocol>`,
	// for example, `80/udp`.
	//
	// If a container's port is mapped for multiple protocols, separate entries
	// are added to the mapping table.
	PortBindings *PortMap `json:"PortBindings,omitempty"`

	// Gives the container full access to the host.
	Privileged *bool `json:"Privileged,omitempty"`

	// Allocates an ephemeral host port for all of a container's
	// exposed ports.
	//
	// Ports are de-allocated when the container stops and allocated when
	// the container starts. The allocated port might be changed when
	// restarting the container.
	//
	// The port is selected from the ephemeral port range that depends on
	// the kernel. For example, on Linux the range is defined by
	// `/proc/sys/net/ipv4/ip_local_port_range`.
	PublishAllPorts *bool `json:"PublishAllPorts,omitempty"`

	// The list of paths to be set as read-only inside the container
	// (this overrides the default set of paths).
	ReadonlyPaths *[]string `json:"ReadonlyPaths,omitempty"`

	// Mount the container's root filesystem as read only.
	ReadonlyRootfs *bool `json:"ReadonlyRootfs,omitempty"`

	// The behavior to apply when the container exits. The default is not to
	// restart.
	//
	// An ever increasing delay (double the previous delay, starting at 100ms) is
	// added before each restart to prevent flooding the server.
	RestartPolicy *RestartPolicy `json:"RestartPolicy,omitempty"`

	// Runtime to use with this container.
	Runtime *string `json:"Runtime,omitempty"`

	// A list of string values to customize labels for MLS systems, such as SELinux.
	SecurityOpt *[]string `json:"SecurityOpt,omitempty"`

	// Size of `/dev/shm` in bytes. If omitted, the system uses 64MB.
	ShmSize *int `json:"ShmSize,omitempty"`

	// Storage driver options for this container, in the form `{"size": "120G"}`.
	StorageOpt *HostConfig_StorageOpt `json:"StorageOpt,omitempty"`

	// A list of kernel parameters (sysctls) to set in the container.
	// For example:
	//
	// ```
	// {"net.ipv4.ip_forward": "1"}
	// ```
	Sysctls *HostConfig_Sysctls `json:"Sysctls,omitempty"`

	// A map of container directories which should be replaced by tmpfs
	// mounts, and their corresponding mount options. For example:
	//
	// ```
	// { "/run": "rw,noexec,nosuid,size=65536k" }
	// ```
	Tmpfs *HostConfig_Tmpfs `json:"Tmpfs,omitempty"`

	// UTS namespace to use for the container.
	UTSMode *string `json:"UTSMode,omitempty"`

	// Sets the usernamespace mode for the container when usernamespace
	// remapping option is enabled.
	UsernsMode *string `json:"UsernsMode,omitempty"`

	// Driver that this container uses to mount volumes.
	VolumeDriver *string `json:"VolumeDriver,omitempty"`

	// A list of volumes to inherit from another container, specified in
	// the form `<container name>[:<ro|rw>]`.
	VolumesFrom *[]string `json:"VolumesFrom,omitempty"`
}

// cgroup namespace mode for the container. Possible values are:
//
// - `"private"`: the container runs in its own private cgroup namespace
// - `"host"`: use the host system's cgroup namespace
//
// If not specified, the daemon default is used, which can either be `"private"`
// or `"host"`, depending on daemon version, kernel support and configuration.
type HostConfigCgroupnsMode string

// Isolation technology of the container. (Windows only)
type HostConfigIsolation string

// HostConfig_LogConfig_Config defines model for HostConfig.LogConfig.Config.
type HostConfig_LogConfig_Config struct {
	AdditionalProperties map[string]string `json:"-"`
}

// HostConfigLogConfigType defines model for HostConfig.LogConfig.Type.
type HostConfigLogConfigType string

// Storage driver options for this container, in the form `{"size": "120G"}`.
type HostConfig_StorageOpt struct {
	AdditionalProperties map[string]string `json:"-"`
}

// A list of kernel parameters (sysctls) to set in the container.
// For example:
//
// ```
// {"net.ipv4.ip_forward": "1"}
// ```
type HostConfig_Sysctls struct {
	AdditionalProperties map[string]string `json:"-"`
}

// A map of container directories which should be replaced by tmpfs
// mounts, and their corresponding mount options. For example:
//
// ```
// { "/run": "rw,noexec,nosuid,size=65536k" }
// ```
type HostConfig_Tmpfs struct {
	AdditionalProperties map[string]string `json:"-"`
}

// IPAM defines model for IPAM.
type IPAM struct {
	// List of IPAM configuration options, specified as a map:
	//
	// ```
	// {"Subnet": <CIDR>, "IPRange": <CIDR>, "Gateway": <IP address>, "AuxAddress": <device_name:IP address>}
	// ```
	Config *[]struct {
		AdditionalProperties map[string]string `json:"-"`
	} `json:"Config,omitempty"`

	// Name of the IPAM driver to use.
	Driver *string `json:"Driver,omitempty"`

	// Driver-specific options, specified as a map.
	Options *IPAM_Options `json:"Options,omitempty"`
}

// Driver-specific options, specified as a map.
type IPAM_Options struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Response to an API call that returns just an Id
type IdResponse struct {
	// The id of the newly created object.
	Id string `json:"Id"`
}

// Image defines model for Image.
type Image struct {
	Architecture string `json:"Architecture"`
	Author       string `json:"Author"`
	Comment      string `json:"Comment"`

	// Configuration for a container that is portable between hosts
	Config    *ContainerConfig `json:"Config,omitempty"`
	Container string           `json:"Container"`

	// Configuration for a container that is portable between hosts
	ContainerConfig *ContainerConfig `json:"ContainerConfig,omitempty"`
	Created         string           `json:"Created"`
	DockerVersion   string           `json:"DockerVersion"`

	// Information about a container's graph driver.
	GraphDriver GraphDriverData `json:"GraphDriver"`
	Id          string          `json:"Id"`
	Metadata    *struct {
		LastTagTime *string `json:"LastTagTime,omitempty"`
	} `json:"Metadata,omitempty"`
	Os          string    `json:"Os"`
	OsVersion   *string   `json:"OsVersion,omitempty"`
	Parent      string    `json:"Parent"`
	RepoDigests *[]string `json:"RepoDigests,omitempty"`
	RepoTags    *[]string `json:"RepoTags,omitempty"`
	RootFS      struct {
		BaseLayer *string   `json:"BaseLayer,omitempty"`
		Layers    *[]string `json:"Layers,omitempty"`
		Type      string    `json:"Type"`
	} `json:"RootFS"`
	Size        int64 `json:"Size"`
	VirtualSize int64 `json:"VirtualSize"`
}

// ImageDeleteResponseItem defines model for ImageDeleteResponseItem.
type ImageDeleteResponseItem struct {
	// The image ID of an image that was deleted
	Deleted *string `json:"Deleted,omitempty"`

	// The image ID of an image that was untagged
	Untagged *string `json:"Untagged,omitempty"`
}

// ImageSummary defines model for ImageSummary.
type ImageSummary struct {
	Containers  int                 `json:"Containers"`
	Created     int                 `json:"Created"`
	Id          string              `json:"Id"`
	Labels      ImageSummary_Labels `json:"Labels"`
	ParentId    string              `json:"ParentId"`
	RepoDigests []string            `json:"RepoDigests"`
	RepoTags    []string            `json:"RepoTags"`
	SharedSize  int                 `json:"SharedSize"`
	Size        int                 `json:"Size"`
	VirtualSize int                 `json:"VirtualSize"`
}

// ImageSummary_Labels defines model for ImageSummary.Labels.
type ImageSummary_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// IndexInfo contains information about a registry.
type IndexInfo struct {
	// List of mirrors, expressed as URIs.
	Mirrors *[]string `json:"Mirrors,omitempty"`

	// Name of the registry, such as "docker.io".
	Name *string `json:"Name,omitempty"`

	// Indicates whether this is an official registry (i.e., Docker Hub / docker.io)
	Official *bool `json:"Official,omitempty"`

	// Indicates if the registry is part of the list of insecure
	// registries.
	//
	// If `false`, the registry is insecure. Insecure registries accept
	// un-encrypted (HTTP) and/or untrusted (HTTPS with certificates from
	// unknown CAs) communication.
	//
	// > **Warning**: Insecure registries can be useful when running a local
	// > registry. However, because its use creates security vulnerabilities
	// > it should ONLY be enabled for testing purposes. For increased
	// > security, users should add their CA to their system's list of
	// > trusted CAs instead of enabling this option.
	Secure *bool `json:"Secure,omitempty"`
}

// JoinTokens contains the tokens workers and managers need to join the swarm.
type JoinTokens struct {
	// The token managers can use to join the swarm.
	Manager *string `json:"Manager,omitempty"`

	// The token workers can use to join the swarm.
	Worker *string `json:"Worker,omitempty"`
}

// An object describing a limit on resources which can be requested by a task.
type Limit struct {
	MemoryBytes *int64 `json:"MemoryBytes,omitempty"`
	NanoCPUs    *int64 `json:"NanoCPUs,omitempty"`

	// Limits the maximum number of PIDs in the container. Set `0` for unlimited.
	Pids *int64 `json:"Pids,omitempty"`
}

// Current local status of this node.
type LocalNodeState string

// ManagerStatus represents the status of a manager.
//
// It provides the current status of a node's manager component, if the node
// is a manager.
type ManagerStatus struct {
	// The IP address and port at which the manager is reachable.
	Addr   *string `json:"Addr,omitempty"`
	Leader *bool   `json:"Leader,omitempty"`

	// Reachability represents the reachability of a node.
	Reachability *Reachability `json:"Reachability,omitempty"`
}

// Mount defines model for Mount.
type Mount struct {
	// Optional configuration for the `bind` type.
	BindOptions *struct {
		// Disable recursive bind mount.
		NonRecursive *bool `json:"NonRecursive,omitempty"`

		// A propagation mode with the value `[r]private`, `[r]shared`, or `[r]slave`.
		Propagation *MountBindOptionsPropagation `json:"Propagation,omitempty"`
	} `json:"BindOptions,omitempty"`

	// The consistency requirement for the mount: `default`, `consistent`, `cached`, or `delegated`.
	Consistency *string `json:"Consistency,omitempty"`

	// Whether the mount should be read-only.
	ReadOnly *bool `json:"ReadOnly,omitempty"`

	// Mount source (e.g. a volume name, a host path).
	Source *string `json:"Source,omitempty"`

	// Container path.
	Target *string `json:"Target,omitempty"`

	// Optional configuration for the `tmpfs` type.
	TmpfsOptions *struct {
		// The permission mode for the tmpfs mount in an integer.
		Mode *int `json:"Mode,omitempty"`

		// The size for the tmpfs mount in bytes.
		SizeBytes *int64 `json:"SizeBytes,omitempty"`
	} `json:"TmpfsOptions,omitempty"`

	// The mount type. Available types:
	//
	// - `bind` Mounts a file or directory from the host into the container. Must exist prior to creating the container.
	// - `volume` Creates a volume with the given name and options (or uses a pre-existing volume with the same name and options). These are **not** removed when the container is removed.
	// - `tmpfs` Create a tmpfs with the given options. The mount source cannot be specified for tmpfs.
	// - `npipe` Mounts a named pipe from the host into the container. Must exist prior to creating the container.
	Type *MountType `json:"Type,omitempty"`

	// Optional configuration for the `volume` type.
	VolumeOptions *struct {
		// Map of driver specific options
		DriverConfig *struct {
			// Name of the driver to use to create the volume.
			Name *string `json:"Name,omitempty"`

			// key/value map of driver specific options.
			Options *Mount_VolumeOptions_DriverConfig_Options `json:"Options,omitempty"`
		} `json:"DriverConfig,omitempty"`

		// User-defined key/value metadata.
		Labels *Mount_VolumeOptions_Labels `json:"Labels,omitempty"`

		// Populate volume with data from the target.
		NoCopy *bool `json:"NoCopy,omitempty"`
	} `json:"VolumeOptions,omitempty"`
}

// A propagation mode with the value `[r]private`, `[r]shared`, or `[r]slave`.
type MountBindOptionsPropagation string

// The mount type. Available types:
//
// - `bind` Mounts a file or directory from the host into the container. Must exist prior to creating the container.
// - `volume` Creates a volume with the given name and options (or uses a pre-existing volume with the same name and options). These are **not** removed when the container is removed.
// - `tmpfs` Create a tmpfs with the given options. The mount source cannot be specified for tmpfs.
// - `npipe` Mounts a named pipe from the host into the container. Must exist prior to creating the container.
type MountType string

// key/value map of driver specific options.
type Mount_VolumeOptions_DriverConfig_Options struct {
	AdditionalProperties map[string]string `json:"-"`
}

// User-defined key/value metadata.
type Mount_VolumeOptions_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// A mount point inside a container
type MountPoint struct {
	Destination *string `json:"Destination,omitempty"`
	Driver      *string `json:"Driver,omitempty"`
	Mode        *string `json:"Mode,omitempty"`
	Name        *string `json:"Name,omitempty"`
	Propagation *string `json:"Propagation,omitempty"`
	RW          *bool   `json:"RW,omitempty"`
	Source      *string `json:"Source,omitempty"`
	Type        *string `json:"Type,omitempty"`
}

// Network defines model for Network.
type Network struct {
	Attachable *bool               `json:"Attachable,omitempty"`
	Containers *Network_Containers `json:"Containers,omitempty"`
	Created    *string             `json:"Created,omitempty"`
	Driver     *string             `json:"Driver,omitempty"`
	EnableIPv6 *bool               `json:"EnableIPv6,omitempty"`
	IPAM       *IPAM               `json:"IPAM,omitempty"`
	Id         *string             `json:"Id,omitempty"`
	Ingress    *bool               `json:"Ingress,omitempty"`
	Internal   *bool               `json:"Internal,omitempty"`
	Labels     *Network_Labels     `json:"Labels,omitempty"`
	Name       *string             `json:"Name,omitempty"`
	Options    *Network_Options    `json:"Options,omitempty"`
	Scope      *string             `json:"Scope,omitempty"`
}

// Network_Containers defines model for Network.Containers.
type Network_Containers struct {
	AdditionalProperties map[string]NetworkContainer `json:"-"`
}

// Network_Labels defines model for Network.Labels.
type Network_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Network_Options defines model for Network.Options.
type Network_Options struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Specifies how a service should be attached to a particular network.
type NetworkAttachmentConfig struct {
	// Discoverable alternate names for the service on this network.
	Aliases *[]string `json:"Aliases,omitempty"`

	// Driver attachment options for the network target.
	DriverOpts *NetworkAttachmentConfig_DriverOpts `json:"DriverOpts,omitempty"`

	// The target network for attachment. Must be a network name or ID.
	Target *string `json:"Target,omitempty"`
}

// Driver attachment options for the network target.
type NetworkAttachmentConfig_DriverOpts struct {
	AdditionalProperties map[string]string `json:"-"`
}

// NetworkContainer defines model for NetworkContainer.
type NetworkContainer struct {
	EndpointID  *string `json:"EndpointID,omitempty"`
	IPv4Address *string `json:"IPv4Address,omitempty"`
	IPv6Address *string `json:"IPv6Address,omitempty"`
	MacAddress  *string `json:"MacAddress,omitempty"`
	Name        *string `json:"Name,omitempty"`
}

// NetworkSettings exposes the network settings in the API
type NetworkSettings struct {
	// Name of the network'a bridge (for example, `docker0`).
	Bridge *string `json:"Bridge,omitempty"`

	// EndpointID uniquely represents a service endpoint in a Sandbox.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when attached to the
	// > default "bridge" network. Use the information from the "bridge"
	// > network inside the `Networks` map instead, which contains the same
	// > information. This field was deprecated in Docker 1.9 and is scheduled
	// > to be removed in Docker 17.12.0
	EndpointID *string `json:"EndpointID,omitempty"`

	// Gateway address for the default "bridge" network.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when attached to the
	// > default "bridge" network. Use the information from the "bridge"
	// > network inside the `Networks` map instead, which contains the same
	// > information. This field was deprecated in Docker 1.9 and is scheduled
	// > to be removed in Docker 17.12.0
	Gateway *string `json:"Gateway,omitempty"`

	// Global IPv6 address for the default "bridge" network.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when attached to the
	// > default "bridge" network. Use the information from the "bridge"
	// > network inside the `Networks` map instead, which contains the same
	// > information. This field was deprecated in Docker 1.9 and is scheduled
	// > to be removed in Docker 17.12.0
	GlobalIPv6Address *string `json:"GlobalIPv6Address,omitempty"`

	// Mask length of the global IPv6 address.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when attached to the
	// > default "bridge" network. Use the information from the "bridge"
	// > network inside the `Networks` map instead, which contains the same
	// > information. This field was deprecated in Docker 1.9 and is scheduled
	// > to be removed in Docker 17.12.0
	GlobalIPv6PrefixLen *int `json:"GlobalIPv6PrefixLen,omitempty"`

	// Indicates if hairpin NAT should be enabled on the virtual interface.
	HairpinMode *bool `json:"HairpinMode,omitempty"`

	// IPv4 address for the default "bridge" network.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when attached to the
	// > default "bridge" network. Use the information from the "bridge"
	// > network inside the `Networks` map instead, which contains the same
	// > information. This field was deprecated in Docker 1.9 and is scheduled
	// > to be removed in Docker 17.12.0
	IPAddress *string `json:"IPAddress,omitempty"`

	// Mask length of the IPv4 address.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when attached to the
	// > default "bridge" network. Use the information from the "bridge"
	// > network inside the `Networks` map instead, which contains the same
	// > information. This field was deprecated in Docker 1.9 and is scheduled
	// > to be removed in Docker 17.12.0
	IPPrefixLen *int `json:"IPPrefixLen,omitempty"`

	// IPv6 gateway address for this network.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when attached to the
	// > default "bridge" network. Use the information from the "bridge"
	// > network inside the `Networks` map instead, which contains the same
	// > information. This field was deprecated in Docker 1.9 and is scheduled
	// > to be removed in Docker 17.12.0
	IPv6Gateway *string `json:"IPv6Gateway,omitempty"`

	// IPv6 unicast address using the link-local prefix.
	LinkLocalIPv6Address *string `json:"LinkLocalIPv6Address,omitempty"`

	// Prefix length of the IPv6 unicast address.
	LinkLocalIPv6PrefixLen *int `json:"LinkLocalIPv6PrefixLen,omitempty"`

	// MAC address for the container on the default "bridge" network.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when attached to the
	// > default "bridge" network. Use the information from the "bridge"
	// > network inside the `Networks` map instead, which contains the same
	// > information. This field was deprecated in Docker 1.9 and is scheduled
	// > to be removed in Docker 17.12.0
	MacAddress *string `json:"MacAddress,omitempty"`

	// Information about all networks that the container is connected to.
	Networks *NetworkSettings_Networks `json:"Networks,omitempty"`

	// PortMap describes the mapping of container ports to host ports, using the
	// container's port-number and protocol as key in the format `<port>/<protocol>`,
	// for example, `80/udp`.
	//
	// If a container's port is mapped for multiple protocols, separate entries
	// are added to the mapping table.
	Ports *PortMap `json:"Ports,omitempty"`

	// SandboxID uniquely represents a container's network stack.
	SandboxID *string `json:"SandboxID,omitempty"`

	// SandboxKey identifies the sandbox
	SandboxKey             *string    `json:"SandboxKey,omitempty"`
	SecondaryIPAddresses   *[]Address `json:"SecondaryIPAddresses"`
	SecondaryIPv6Addresses *[]Address `json:"SecondaryIPv6Addresses"`
}

// Information about all networks that the container is connected to.
type NetworkSettings_Networks struct {
	AdditionalProperties map[string]EndpointSettings `json:"-"`
}

// NetworkingConfig represents the container's networking configuration for
// each of its interfaces.
// It is used for the networking configs specified in the `docker create`
// and `docker network connect` commands.
type NetworkingConfig struct {
	// A mapping of network name to endpoint configuration for that network.
	EndpointsConfig *NetworkingConfig_EndpointsConfig `json:"EndpointsConfig,omitempty"`
}

// A mapping of network name to endpoint configuration for that network.
type NetworkingConfig_EndpointsConfig struct {
	AdditionalProperties map[string]EndpointSettings `json:"-"`
}

// Node defines model for Node.
type Node struct {
	// Date and time at which the node was added to the swarm in
	// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
	CreatedAt *string `json:"CreatedAt,omitempty"`

	// NodeDescription encapsulates the properties of the Node as reported by the
	// agent.
	Description *NodeDescription `json:"Description,omitempty"`
	ID          *string          `json:"ID,omitempty"`

	// ManagerStatus represents the status of a manager.
	//
	// It provides the current status of a node's manager component, if the node
	// is a manager.
	ManagerStatus *ManagerStatus `json:"ManagerStatus"`
	Spec          *NodeSpec      `json:"Spec,omitempty"`

	// NodeStatus represents the status of a node.
	//
	// It provides the current status of the node, as seen by the manager.
	Status *NodeStatus `json:"Status,omitempty"`

	// Date and time at which the node was last updated in
	// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
	UpdatedAt *string `json:"UpdatedAt,omitempty"`

	// The version number of the object such as node, service, etc. This is needed
	// to avoid conflicting writes. The client must send the version number along
	// with the modified specification when updating these objects.
	//
	// This approach ensures safe concurrency and determinism in that the change
	// on the object may not be applied if the version number has changed from the
	// last read. In other words, if two update requests specify the same base
	// version, only one of the requests can succeed. As a result, two separate
	// update requests that happen at the same time will not unintentionally
	// overwrite each other.
	Version *ObjectVersion `json:"Version,omitempty"`
}

// NodeDescription encapsulates the properties of the Node as reported by the
// agent.
type NodeDescription struct {
	// EngineDescription provides information about an engine.
	Engine   *EngineDescription `json:"Engine,omitempty"`
	Hostname *string            `json:"Hostname,omitempty"`

	// Platform represents the platform (Arch/OS).
	Platform *Platform `json:"Platform,omitempty"`

	// An object describing the resources which can be advertised by a node and
	// requested by a task.
	Resources *ResourceObject `json:"Resources,omitempty"`

	// Information about the issuer of leaf TLS certificates and the trusted root
	// CA certificate.
	TLSInfo *TLSInfo `json:"TLSInfo,omitempty"`
}

// NodeSpec defines model for NodeSpec.
type NodeSpec struct {
	// Availability of the node.
	Availability *NodeSpecAvailability `json:"Availability,omitempty"`

	// User-defined key/value metadata.
	Labels *NodeSpec_Labels `json:"Labels,omitempty"`

	// Name for the node.
	Name *string `json:"Name,omitempty"`

	// Role of the node.
	Role *NodeSpecRole `json:"Role,omitempty"`
}

// Availability of the node.
type NodeSpecAvailability string

// User-defined key/value metadata.
type NodeSpec_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Role of the node.
type NodeSpecRole string

// NodeState represents the state of a node.
type NodeState string

// NodeStatus represents the status of a node.
//
// It provides the current status of the node, as seen by the manager.
type NodeStatus struct {
	// IP address of the node.
	Addr    *string `json:"Addr,omitempty"`
	Message *string `json:"Message,omitempty"`

	// NodeState represents the state of a node.
	State *NodeState `json:"State,omitempty"`
}

// The version number of the object such as node, service, etc. This is needed
// to avoid conflicting writes. The client must send the version number along
// with the modified specification when updating these objects.
//
// This approach ensures safe concurrency and determinism in that the change
// on the object may not be applied if the version number has changed from the
// last read. In other words, if two update requests specify the same base
// version, only one of the requests can succeed. As a result, two separate
// update requests that happen at the same time will not unintentionally
// overwrite each other.
type ObjectVersion struct {
	Index *uint64 `json:"Index,omitempty"`
}

// Represents a peer-node in the swarm
type PeerNode struct {
	// IP address and ports at which this node can be reached.
	Addr *string `json:"Addr,omitempty"`

	// Unique identifier of for this node in the swarm.
	NodeID *string `json:"NodeID,omitempty"`
}

// Platform represents the platform (Arch/OS).
type Platform struct {
	// Architecture represents the hardware architecture (for example,
	// `x86_64`).
	Architecture *string `json:"Architecture,omitempty"`

	// OS represents the Operating System (for example, `linux` or `windows`).
	OS *string `json:"OS,omitempty"`
}

// A plugin for the Engine API
type Plugin struct {
	// The config of a plugin.
	Config struct {
		Args struct {
			Description string   `json:"Description"`
			Name        string   `json:"Name"`
			Settable    []string `json:"Settable"`
			Value       []string `json:"Value"`
		} `json:"Args"`
		Description string `json:"Description"`

		// Docker Version used to create the plugin
		DockerVersion *string     `json:"DockerVersion,omitempty"`
		Documentation string      `json:"Documentation"`
		Entrypoint    []string    `json:"Entrypoint"`
		Env           []PluginEnv `json:"Env"`

		// The interface between Docker and the plugin
		Interface struct {
			// Protocol to use for clients connecting to the plugin.
			ProtocolScheme *PluginConfigInterfaceProtocolScheme `json:"ProtocolScheme,omitempty"`
			Socket         string                               `json:"Socket"`
			Types          []PluginInterfaceType                `json:"Types"`
		} `json:"Interface"`
		IpcHost bool `json:"IpcHost"`
		Linux   struct {
			AllowAllDevices bool           `json:"AllowAllDevices"`
			Capabilities    []string       `json:"Capabilities"`
			Devices         []PluginDevice `json:"Devices"`
		} `json:"Linux"`
		Mounts  []PluginMount `json:"Mounts"`
		Network struct {
			Type string `json:"Type"`
		} `json:"Network"`
		PidHost         bool   `json:"PidHost"`
		PropagatedMount string `json:"PropagatedMount"`
		User            *struct {
			GID *uint32 `json:"GID,omitempty"`
			UID *uint32 `json:"UID,omitempty"`
		} `json:"User,omitempty"`
		WorkDir string `json:"WorkDir"`
		Rootfs  *struct {
			DiffIds *[]string `json:"diff_ids,omitempty"`
			Type    *string   `json:"type,omitempty"`
		} `json:"rootfs,omitempty"`
	} `json:"Config"`

	// True if the plugin is running. False if the plugin is not running, only installed.
	Enabled bool    `json:"Enabled"`
	Id      *string `json:"Id,omitempty"`
	Name    string  `json:"Name"`

	// plugin remote reference used to push/pull the plugin
	PluginReference *string `json:"PluginReference,omitempty"`

	// Settings that can be modified by users.
	Settings struct {
		Args    []string       `json:"Args"`
		Devices []PluginDevice `json:"Devices"`
		Env     []string       `json:"Env"`
		Mounts  []PluginMount  `json:"Mounts"`
	} `json:"Settings"`
}

// Protocol to use for clients connecting to the plugin.
type PluginConfigInterfaceProtocolScheme string

// PluginDevice defines model for PluginDevice.
type PluginDevice struct {
	Description string   `json:"Description"`
	Name        string   `json:"Name"`
	Path        string   `json:"Path"`
	Settable    []string `json:"Settable"`
}

// PluginEnv defines model for PluginEnv.
type PluginEnv struct {
	Description string   `json:"Description"`
	Name        string   `json:"Name"`
	Settable    []string `json:"Settable"`
	Value       string   `json:"Value"`
}

// PluginInterfaceType defines model for PluginInterfaceType.
type PluginInterfaceType struct {
	Capability string `json:"Capability"`
	Prefix     string `json:"Prefix"`
	Version    string `json:"Version"`
}

// PluginMount defines model for PluginMount.
type PluginMount struct {
	Description string   `json:"Description"`
	Destination string   `json:"Destination"`
	Name        string   `json:"Name"`
	Options     []string `json:"Options"`
	Settable    []string `json:"Settable"`
	Source      string   `json:"Source"`
	Type        string   `json:"Type"`
}

// Available plugins per type.
//
// <p><br /></p>
//
// > **Note**: Only unmanaged (V1) plugins are included in this list.
// > V1 plugins are "lazily" loaded, and are not returned in this list
// > if there is no resource using the plugin.
type PluginsInfo struct {
	// Names of available authorization plugins.
	Authorization *[]string `json:"Authorization,omitempty"`

	// Names of available logging-drivers, and logging-driver plugins.
	Log *[]string `json:"Log,omitempty"`

	// Names of available network-drivers, and network-driver plugins.
	Network *[]string `json:"Network,omitempty"`

	// Names of available volume-drivers, and network-driver plugins.
	Volume *[]string `json:"Volume,omitempty"`
}

// An open port on a container
type Port struct {
	// Host IP address that the container's port is mapped to
	IP *string `json:"IP,omitempty"`

	// Port on the container
	PrivatePort uint16 `json:"PrivatePort"`

	// Port exposed on the host
	PublicPort *uint16  `json:"PublicPort,omitempty"`
	Type       PortType `json:"Type"`
}

// PortType defines model for Port.Type.
type PortType string

// PortBinding represents a binding between a host IP address and a host
// port.
type PortBinding struct {
	// Host IP address that the container's port is mapped to.
	HostIp *string `json:"HostIp,omitempty"`

	// Host port number that the container's port is mapped to.
	HostPort *string `json:"HostPort,omitempty"`
}

// PortMap describes the mapping of container ports to host ports, using the
// container's port-number and protocol as key in the format `<port>/<protocol>`,
// for example, `80/udp`.
//
// If a container's port is mapped for multiple protocols, separate entries
// are added to the mapping table.
type PortMap struct {
	AdditionalProperties map[string][]PortBinding `json:"-"`
}

// ProcessConfig defines model for ProcessConfig.
type ProcessConfig struct {
	Arguments  *[]string `json:"arguments,omitempty"`
	Entrypoint *string   `json:"entrypoint,omitempty"`
	Privileged *bool     `json:"privileged,omitempty"`
	Tty        *bool     `json:"tty,omitempty"`
	User       *string   `json:"user,omitempty"`
}

// Reachability represents the reachability of a node.
type Reachability string

// RegistryServiceConfig stores daemon registry services configuration.
type RegistryServiceConfig struct {
	// List of IP ranges to which nondistributable artifacts can be pushed,
	// using the CIDR syntax [RFC 4632](https://tools.ietf.org/html/4632).
	//
	// Some images (for example, Windows base images) contain artifacts
	// whose distribution is restricted by license. When these images are
	// pushed to a registry, restricted artifacts are not included.
	//
	// This configuration override this behavior, and enables the daemon to
	// push nondistributable artifacts to all registries whose resolved IP
	// address is within the subnet described by the CIDR syntax.
	//
	// This option is useful when pushing images containing
	// nondistributable artifacts to a registry on an air-gapped network so
	// hosts on that network can pull the images without connecting to
	// another server.
	//
	// > **Warning**: Nondistributable artifacts typically have restrictions
	// > on how and where they can be distributed and shared. Only use this
	// > feature to push artifacts to private registries and ensure that you
	// > are in compliance with any terms that cover redistributing
	// > nondistributable artifacts.
	AllowNondistributableArtifactsCIDRs *[]string `json:"AllowNondistributableArtifactsCIDRs,omitempty"`

	// List of registry hostnames to which nondistributable artifacts can be
	// pushed, using the format `<hostname>[:<port>]` or `<IP address>[:<port>]`.
	//
	// Some images (for example, Windows base images) contain artifacts
	// whose distribution is restricted by license. When these images are
	// pushed to a registry, restricted artifacts are not included.
	//
	// This configuration override this behavior for the specified
	// registries.
	//
	// This option is useful when pushing images containing
	// nondistributable artifacts to a registry on an air-gapped network so
	// hosts on that network can pull the images without connecting to
	// another server.
	//
	// > **Warning**: Nondistributable artifacts typically have restrictions
	// > on how and where they can be distributed and shared. Only use this
	// > feature to push artifacts to private registries and ensure that you
	// > are in compliance with any terms that cover redistributing
	// > nondistributable artifacts.
	AllowNondistributableArtifactsHostnames *[]string                           `json:"AllowNondistributableArtifactsHostnames,omitempty"`
	IndexConfigs                            *RegistryServiceConfig_IndexConfigs `json:"IndexConfigs,omitempty"`

	// List of IP ranges of insecure registries, using the CIDR syntax
	// ([RFC 4632](https://tools.ietf.org/html/4632)). Insecure registries
	// accept un-encrypted (HTTP) and/or untrusted (HTTPS with certificates
	// from unknown CAs) communication.
	//
	// By default, local registries (`127.0.0.0/8`) are configured as
	// insecure. All other registries are secure. Communicating with an
	// insecure registry is not possible if the daemon assumes that registry
	// is secure.
	//
	// This configuration override this behavior, insecure communication with
	// registries whose resolved IP address is within the subnet described by
	// the CIDR syntax.
	//
	// Registries can also be marked insecure by hostname. Those registries
	// are listed under `IndexConfigs` and have their `Secure` field set to
	// `false`.
	//
	// > **Warning**: Using this option can be useful when running a local
	// > registry, but introduces security vulnerabilities. This option
	// > should therefore ONLY be used for testing purposes. For increased
	// > security, users should add their CA to their system's list of trusted
	// > CAs instead of enabling this option.
	InsecureRegistryCIDRs *[]string `json:"InsecureRegistryCIDRs,omitempty"`

	// List of registry URLs that act as a mirror for the official
	// (`docker.io`) registry.
	Mirrors *[]string `json:"Mirrors,omitempty"`
}

// RegistryServiceConfig_IndexConfigs defines model for RegistryServiceConfig.IndexConfigs.
type RegistryServiceConfig_IndexConfigs struct {
	AdditionalProperties map[string]IndexInfo `json:"-"`
}

// An object describing the resources which can be advertised by a node and
// requested by a task.
type ResourceObject struct {
	// User-defined resources can be either Integer resources (e.g, `SSD=3`) or
	// String resources (e.g, `GPU=UUID1`).
	GenericResources *GenericResources `json:"GenericResources,omitempty"`
	MemoryBytes      *int64            `json:"MemoryBytes,omitempty"`
	NanoCPUs         *int64            `json:"NanoCPUs,omitempty"`
}

// A container's resources (cgroups config, ulimits, etc)
type Resources struct {
	// Limit read rate (bytes per second) from a device, in the form:
	//
	// ```
	// [{"Path": "device_path", "Rate": rate}]
	// ```
	BlkioDeviceReadBps *[]ThrottleDevice `json:"BlkioDeviceReadBps,omitempty"`

	// Limit read rate (IO per second) from a device, in the form:
	//
	// ```
	// [{"Path": "device_path", "Rate": rate}]
	// ```
	BlkioDeviceReadIOps *[]ThrottleDevice `json:"BlkioDeviceReadIOps,omitempty"`

	// Limit write rate (bytes per second) to a device, in the form:
	//
	// ```
	// [{"Path": "device_path", "Rate": rate}]
	// ```
	BlkioDeviceWriteBps *[]ThrottleDevice `json:"BlkioDeviceWriteBps,omitempty"`

	// Limit write rate (IO per second) to a device, in the form:
	//
	// ```
	// [{"Path": "device_path", "Rate": rate}]
	// ```
	BlkioDeviceWriteIOps *[]ThrottleDevice `json:"BlkioDeviceWriteIOps,omitempty"`

	// Block IO weight (relative weight).
	BlkioWeight *int `json:"BlkioWeight,omitempty"`

	// Block IO weight (relative device weight) in the form:
	//
	// ```
	// [{"Path": "device_path", "Weight": weight}]
	// ```
	BlkioWeightDevice *[]struct {
		Path   *string `json:"Path,omitempty"`
		Weight *int    `json:"Weight,omitempty"`
	} `json:"BlkioWeightDevice,omitempty"`

	// Path to `cgroups` under which the container's `cgroup` is created. If
	// the path is not absolute, the path is considered to be relative to the
	// `cgroups` path of the init process. Cgroups are created if they do not
	// already exist.
	CgroupParent *string `json:"CgroupParent,omitempty"`

	// The number of usable CPUs (Windows only).
	//
	// On Windows Server containers, the processor resource controls are
	// mutually exclusive. The order of precedence is `CPUCount` first, then
	// `CPUShares`, and `CPUPercent` last.
	CpuCount *int64 `json:"CpuCount,omitempty"`

	// The usable percentage of the available CPUs (Windows only).
	//
	// On Windows Server containers, the processor resource controls are
	// mutually exclusive. The order of precedence is `CPUCount` first, then
	// `CPUShares`, and `CPUPercent` last.
	CpuPercent *int64 `json:"CpuPercent,omitempty"`

	// The length of a CPU period in microseconds.
	CpuPeriod *int64 `json:"CpuPeriod,omitempty"`

	// Microseconds of CPU time that the container can get in a CPU period.
	CpuQuota *int64 `json:"CpuQuota,omitempty"`

	// The length of a CPU real-time period in microseconds. Set to 0 to
	// allocate no time allocated to real-time tasks.
	CpuRealtimePeriod *int64 `json:"CpuRealtimePeriod,omitempty"`

	// The length of a CPU real-time runtime in microseconds. Set to 0 to
	// allocate no time allocated to real-time tasks.
	CpuRealtimeRuntime *int64 `json:"CpuRealtimeRuntime,omitempty"`

	// An integer value representing this container's relative CPU weight
	// versus other containers.
	CpuShares *int `json:"CpuShares,omitempty"`

	// CPUs in which to allow execution (e.g., `0-3`, `0,1`).
	CpusetCpus *string `json:"CpusetCpus,omitempty"`

	// Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only
	// effective on NUMA systems.
	CpusetMems *string `json:"CpusetMems,omitempty"`

	// a list of cgroup rules to apply to the container
	DeviceCgroupRules *[]string `json:"DeviceCgroupRules,omitempty"`

	// A list of requests for devices to be sent to device drivers.
	DeviceRequests *[]DeviceRequest `json:"DeviceRequests,omitempty"`

	// A list of devices to add to the container.
	Devices *[]DeviceMapping `json:"Devices,omitempty"`

	// Maximum IO in bytes per second for the container system drive
	// (Windows only).
	IOMaximumBandwidth *int64 `json:"IOMaximumBandwidth,omitempty"`

	// Maximum IOps for the container system drive (Windows only)
	IOMaximumIOps *int64 `json:"IOMaximumIOps,omitempty"`

	// Run an init inside the container that forwards signals and reaps
	// processes. This field is omitted if empty, and the default (as
	// configured on the daemon) is used.
	Init *bool `json:"Init"`

	// Kernel memory limit in bytes.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is deprecated as the kernel 5.4 deprecated
	// > `kmem.limit_in_bytes`.
	KernelMemory *int64 `json:"KernelMemory,omitempty"`

	// Hard limit for kernel TCP buffer memory (in bytes).
	KernelMemoryTCP *int64 `json:"KernelMemoryTCP,omitempty"`

	// Memory limit in bytes.
	Memory *int64 `json:"Memory,omitempty"`

	// Memory soft limit in bytes.
	MemoryReservation *int64 `json:"MemoryReservation,omitempty"`

	// Total memory limit (memory + swap). Set as `-1` to enable unlimited
	// swap.
	MemorySwap *int64 `json:"MemorySwap,omitempty"`

	// Tune a container's memory swappiness behavior. Accepts an integer
	// between 0 and 100.
	MemorySwappiness *int64 `json:"MemorySwappiness,omitempty"`

	// CPU quota in units of 10<sup>-9</sup> CPUs.
	NanoCpus *int64 `json:"NanoCpus,omitempty"`

	// Disable OOM Killer for the container.
	OomKillDisable *bool `json:"OomKillDisable,omitempty"`

	// Tune a container's PIDs limit. Set `0` or `-1` for unlimited, or `null`
	// to not change.
	PidsLimit *int64 `json:"PidsLimit"`

	// A list of resource limits to set in the container. For example:
	//
	// ```
	// {"Name": "nofile", "Soft": 1024, "Hard": 2048}
	// ```
	Ulimits *[]struct {
		// Hard limit
		Hard *int `json:"Hard,omitempty"`

		// Name of ulimit
		Name *string `json:"Name,omitempty"`

		// Soft limit
		Soft *int `json:"Soft,omitempty"`
	} `json:"Ulimits,omitempty"`
}

// The behavior to apply when the container exits. The default is not to
// restart.
//
// An ever increasing delay (double the previous delay, starting at 100ms) is
// added before each restart to prevent flooding the server.
type RestartPolicy struct {
	// If `on-failure` is used, the number of times to retry before giving up.
	MaximumRetryCount *int `json:"MaximumRetryCount,omitempty"`

	// - Empty string means not to restart
	// - `always` Always restart
	// - `unless-stopped` Restart always except when the user has manually stopped the container
	// - `on-failure` Restart only when the container exit code is non-zero
	Name *RestartPolicyName `json:"Name,omitempty"`
}

// - Empty string means not to restart
// - `always` Always restart
// - `unless-stopped` Restart always except when the user has manually stopped the container
// - `on-failure` Restart only when the container exit code is non-zero
type RestartPolicyName string

// Runtime describes an [OCI compliant](https://github.com/opencontainers/runtime-spec)
// runtime.
//
// The runtime is invoked by the daemon via the `containerd` daemon. OCI
// runtimes act as an interface to the Linux kernel namespaces, cgroups,
// and SELinux.
type Runtime struct {
	// Name and, optional, path, of the OCI executable binary.
	//
	// If the path is omitted, the daemon searches the host's `$PATH` for the
	// binary and uses the first result.
	Path *string `json:"path,omitempty"`

	// List of command-line arguments to pass to the runtime when invoked.
	RuntimeArgs *[]string `json:"runtimeArgs"`
}

// Secret defines model for Secret.
type Secret struct {
	CreatedAt *string     `json:"CreatedAt,omitempty"`
	ID        *string     `json:"ID,omitempty"`
	Spec      *SecretSpec `json:"Spec,omitempty"`
	UpdatedAt *string     `json:"UpdatedAt,omitempty"`

	// The version number of the object such as node, service, etc. This is needed
	// to avoid conflicting writes. The client must send the version number along
	// with the modified specification when updating these objects.
	//
	// This approach ensures safe concurrency and determinism in that the change
	// on the object may not be applied if the version number has changed from the
	// last read. In other words, if two update requests specify the same base
	// version, only one of the requests can succeed. As a result, two separate
	// update requests that happen at the same time will not unintentionally
	// overwrite each other.
	Version *ObjectVersion `json:"Version,omitempty"`
}

// SecretSpec defines model for SecretSpec.
type SecretSpec struct {
	// Base64-url-safe-encoded ([RFC 4648](https://tools.ietf.org/html/rfc4648#section-5))
	// data to store as secret.
	//
	// This field is only used to _create_ a secret, and is not returned by
	// other endpoints.
	Data *string `json:"Data,omitempty"`

	// Driver represents a driver (network, logging, secrets).
	Driver *Driver `json:"Driver,omitempty"`

	// User-defined key/value metadata.
	Labels *SecretSpec_Labels `json:"Labels,omitempty"`

	// User-defined name of the secret.
	Name *string `json:"Name,omitempty"`

	// Driver represents a driver (network, logging, secrets).
	Templating *Driver `json:"Templating,omitempty"`
}

// User-defined key/value metadata.
type SecretSpec_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Service defines model for Service.
type Service struct {
	CreatedAt *string `json:"CreatedAt,omitempty"`
	Endpoint  *struct {
		Ports *[]EndpointPortConfig `json:"Ports,omitempty"`

		// Properties that can be configured to access and load balance a service.
		Spec       *EndpointSpec `json:"Spec,omitempty"`
		VirtualIPs *[]struct {
			Addr      *string `json:"Addr,omitempty"`
			NetworkID *string `json:"NetworkID,omitempty"`
		} `json:"VirtualIPs,omitempty"`
	} `json:"Endpoint,omitempty"`
	ID *string `json:"ID,omitempty"`

	// The status of the service when it is in one of ReplicatedJob or
	// GlobalJob modes. Absent on Replicated and Global mode services. The
	// JobIteration is an ObjectVersion, but unlike the Service's version,
	// does not need to be sent with an update request.
	JobStatus *struct {
		// The version number of the object such as node, service, etc. This is needed
		// to avoid conflicting writes. The client must send the version number along
		// with the modified specification when updating these objects.
		//
		// This approach ensures safe concurrency and determinism in that the change
		// on the object may not be applied if the version number has changed from the
		// last read. In other words, if two update requests specify the same base
		// version, only one of the requests can succeed. As a result, two separate
		// update requests that happen at the same time will not unintentionally
		// overwrite each other.
		JobIteration *ObjectVersion `json:"JobIteration,omitempty"`

		// The last time, as observed by the server, that this job was
		// started.
		LastExecution *string `json:"LastExecution,omitempty"`
	} `json:"JobStatus,omitempty"`

	// The status of the service's tasks. Provided only when requested as
	// part of a ServiceList operation.
	ServiceStatus *struct {
		// The number of tasks for a job that are in the Completed state.
		// This field must be cross-referenced with the service type, as the
		// value of 0 may mean the service is not in a job mode, or it may
		// mean the job-mode service has no tasks yet Completed.
		CompletedTasks *uint64 `json:"CompletedTasks,omitempty"`

		// The number of tasks for the service desired to be running.
		// For replicated services, this is the replica count from the
		// service spec. For global services, this is computed by taking
		// count of all tasks for the service with a Desired State other
		// than Shutdown.
		DesiredTasks *uint64 `json:"DesiredTasks,omitempty"`

		// The number of tasks for the service currently in the Running state.
		RunningTasks *uint64 `json:"RunningTasks,omitempty"`
	} `json:"ServiceStatus,omitempty"`

	// User modifiable configuration for a service.
	Spec *ServiceSpec `json:"Spec,omitempty"`

	// The status of a service update.
	UpdateStatus *struct {
		CompletedAt *string                   `json:"CompletedAt,omitempty"`
		Message     *string                   `json:"Message,omitempty"`
		StartedAt   *string                   `json:"StartedAt,omitempty"`
		State       *ServiceUpdateStatusState `json:"State,omitempty"`
	} `json:"UpdateStatus,omitempty"`
	UpdatedAt *string `json:"UpdatedAt,omitempty"`

	// The version number of the object such as node, service, etc. This is needed
	// to avoid conflicting writes. The client must send the version number along
	// with the modified specification when updating these objects.
	//
	// This approach ensures safe concurrency and determinism in that the change
	// on the object may not be applied if the version number has changed from the
	// last read. In other words, if two update requests specify the same base
	// version, only one of the requests can succeed. As a result, two separate
	// update requests that happen at the same time will not unintentionally
	// overwrite each other.
	Version *ObjectVersion `json:"Version,omitempty"`
}

// ServiceUpdateStatusState defines model for Service.UpdateStatus.State.
type ServiceUpdateStatusState string

// User modifiable configuration for a service.
type ServiceSpec struct {
	// Properties that can be configured to access and load balance a service.
	EndpointSpec *EndpointSpec `json:"EndpointSpec,omitempty"`

	// User-defined key/value metadata.
	Labels *ServiceSpec_Labels `json:"Labels,omitempty"`

	// Scheduling mode for the service.
	Mode *struct {
		Global *map[string]interface{} `json:"Global,omitempty"`

		// The mode used for services which run a task to the completed state
		// on each valid node.
		GlobalJob  *map[string]interface{} `json:"GlobalJob,omitempty"`
		Replicated *struct {
			Replicas *int64 `json:"Replicas,omitempty"`
		} `json:"Replicated,omitempty"`

		// The mode used for services with a finite number of tasks that run
		// to a completed state.
		ReplicatedJob *struct {
			// The maximum number of replicas to run simultaneously.
			MaxConcurrent *int64 `json:"MaxConcurrent,omitempty"`

			// The total number of replicas desired to reach the Completed
			// state. If unset, will default to the value of `MaxConcurrent`
			TotalCompletions *int64 `json:"TotalCompletions,omitempty"`
		} `json:"ReplicatedJob,omitempty"`
	} `json:"Mode,omitempty"`

	// Name of the service.
	Name *string `json:"Name,omitempty"`

	// Specifies which networks the service should attach to.
	Networks *[]NetworkAttachmentConfig `json:"Networks,omitempty"`

	// Specification for the rollback strategy of the service.
	RollbackConfig *struct {
		// Amount of time between rollback iterations, in nanoseconds.
		Delay *int64 `json:"Delay,omitempty"`

		// Action to take if an rolled back task fails to run, or stops
		// running during the rollback.
		FailureAction *ServiceSpecRollbackConfigFailureAction `json:"FailureAction,omitempty"`

		// The fraction of tasks that may fail during a rollback before the
		// failure action is invoked, specified as a floating point number
		// between 0 and 1.
		MaxFailureRatio *float32 `json:"MaxFailureRatio,omitempty"`

		// Amount of time to monitor each rolled back task for failures, in
		// nanoseconds.
		Monitor *int64 `json:"Monitor,omitempty"`

		// The order of operations when rolling back a task. Either the old
		// task is shut down before the new task is started, or the new task
		// is started before the old task is shut down.
		Order *ServiceSpecRollbackConfigOrder `json:"Order,omitempty"`

		// Maximum number of tasks to be rolled back in one iteration (0 means
		// unlimited parallelism).
		Parallelism *int64 `json:"Parallelism,omitempty"`
	} `json:"RollbackConfig,omitempty"`

	// User modifiable task configuration.
	TaskTemplate *TaskSpec `json:"TaskTemplate,omitempty"`

	// Specification for the update strategy of the service.
	UpdateConfig *struct {
		// Amount of time between updates, in nanoseconds.
		Delay *int64 `json:"Delay,omitempty"`

		// Action to take if an updated task fails to run, or stops running
		// during the update.
		FailureAction *ServiceSpecUpdateConfigFailureAction `json:"FailureAction,omitempty"`

		// The fraction of tasks that may fail during an update before the
		// failure action is invoked, specified as a floating point number
		// between 0 and 1.
		MaxFailureRatio *float32 `json:"MaxFailureRatio,omitempty"`

		// Amount of time to monitor each updated task for failures, in
		// nanoseconds.
		Monitor *int64 `json:"Monitor,omitempty"`

		// The order of operations when rolling out an updated task. Either
		// the old task is shut down before the new task is started, or the
		// new task is started before the old task is shut down.
		Order *ServiceSpecUpdateConfigOrder `json:"Order,omitempty"`

		// Maximum number of tasks to be updated in one iteration (0 means
		// unlimited parallelism).
		Parallelism *int64 `json:"Parallelism,omitempty"`
	} `json:"UpdateConfig,omitempty"`
}

// User-defined key/value metadata.
type ServiceSpec_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Action to take if an rolled back task fails to run, or stops
// running during the rollback.
type ServiceSpecRollbackConfigFailureAction string

// The order of operations when rolling back a task. Either the old
// task is shut down before the new task is started, or the new task
// is started before the old task is shut down.
type ServiceSpecRollbackConfigOrder string

// Action to take if an updated task fails to run, or stops running
// during the update.
type ServiceSpecUpdateConfigFailureAction string

// The order of operations when rolling out an updated task. Either
// the old task is shut down before the new task is started, or the
// new task is started before the old task is shut down.
type ServiceSpecUpdateConfigOrder string

// ServiceUpdateResponse defines model for ServiceUpdateResponse.
type ServiceUpdateResponse struct {
	// Optional warning messages
	Warnings *[]string `json:"Warnings,omitempty"`
}

// Swarm defines model for Swarm.
type Swarm struct {
	// Embedded struct due to allOf(#/components/schemas/ClusterInfo)
	ClusterInfo `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// JoinTokens contains the tokens workers and managers need to join the swarm.
	JoinTokens *JoinTokens `json:"JoinTokens,omitempty"`
}

// Represents generic information about swarm.
type SwarmInfo struct {
	// ClusterInfo represents information about the swarm as is returned by the
	// "/info" endpoint. Join-tokens are not included.
	Cluster          *ClusterInfo `json:"Cluster"`
	ControlAvailable *bool        `json:"ControlAvailable,omitempty"`
	Error            *string      `json:"Error,omitempty"`

	// Current local status of this node.
	LocalNodeState *LocalNodeState `json:"LocalNodeState,omitempty"`

	// Total number of managers in the swarm.
	Managers *int `json:"Managers"`

	// IP address at which this node can be reached by other nodes in the
	// swarm.
	NodeAddr *string `json:"NodeAddr,omitempty"`

	// Unique identifier of for this node in the swarm.
	NodeID *string `json:"NodeID,omitempty"`

	// Total number of nodes in the swarm.
	Nodes *int `json:"Nodes"`

	// List of ID's and addresses of other managers in the swarm.
	RemoteManagers *[]PeerNode `json:"RemoteManagers"`
}

// User modifiable swarm configuration.
type SwarmSpec struct {
	// CA configuration.
	CAConfig *struct {
		// Configuration for forwarding signing requests to an external
		// certificate authority.
		ExternalCAs *[]struct {
			// The root CA certificate (in PEM format) this external CA uses
			// to issue TLS certificates (assumed to be to the current swarm
			// root CA certificate if not provided).
			CACert *string `json:"CACert,omitempty"`

			// An object with key/value pairs that are interpreted as
			// protocol-specific options for the external CA driver.
			Options *SwarmSpec_CAConfig_ExternalCAs_Options `json:"Options,omitempty"`

			// Protocol for communication with the external CA (currently
			// only `cfssl` is supported).
			Protocol *SwarmSpecCAConfigExternalCAsProtocol `json:"Protocol,omitempty"`

			// URL where certificate signing requests should be sent.
			URL *string `json:"URL,omitempty"`
		} `json:"ExternalCAs,omitempty"`

		// An integer whose purpose is to force swarm to generate a new
		// signing CA certificate and key, if none have been specified in
		// `SigningCACert` and `SigningCAKey`
		ForceRotate *uint64 `json:"ForceRotate,omitempty"`

		// The duration node certificates are issued for.
		NodeCertExpiry *int64 `json:"NodeCertExpiry,omitempty"`

		// The desired signing CA certificate for all swarm node TLS leaf
		// certificates, in PEM format.
		SigningCACert *string `json:"SigningCACert,omitempty"`

		// The desired signing CA key for all swarm node TLS leaf certificates,
		// in PEM format.
		SigningCAKey *string `json:"SigningCAKey,omitempty"`
	} `json:"CAConfig"`

	// Dispatcher configuration.
	Dispatcher *struct {
		// The delay for an agent to send a heartbeat to the dispatcher.
		HeartbeatPeriod *int64 `json:"HeartbeatPeriod,omitempty"`
	} `json:"Dispatcher"`

	// Parameters related to encryption-at-rest.
	EncryptionConfig *struct {
		// If set, generate a key and use it to lock data stored on the
		// managers.
		AutoLockManagers *bool `json:"AutoLockManagers,omitempty"`
	} `json:"EncryptionConfig,omitempty"`

	// User-defined key/value metadata.
	Labels *SwarmSpec_Labels `json:"Labels,omitempty"`

	// Name of the swarm.
	Name *string `json:"Name,omitempty"`

	// Orchestration configuration.
	Orchestration *struct {
		// The number of historic tasks to keep per instance or node. If
		// negative, never remove completed or failed tasks.
		TaskHistoryRetentionLimit *int64 `json:"TaskHistoryRetentionLimit,omitempty"`
	} `json:"Orchestration"`

	// Raft configuration.
	Raft *struct {
		// The number of ticks that a follower will wait for a message from
		// the leader before becoming a candidate and starting an election.
		// `ElectionTick` must be greater than `HeartbeatTick`.
		//
		// A tick currently defaults to one second, so these translate
		// directly to seconds currently, but this is NOT guaranteed.
		ElectionTick *int `json:"ElectionTick,omitempty"`

		// The number of ticks between heartbeats. Every HeartbeatTick ticks,
		// the leader will send a heartbeat to the followers.
		//
		// A tick currently defaults to one second, so these translate
		// directly to seconds currently, but this is NOT guaranteed.
		HeartbeatTick *int `json:"HeartbeatTick,omitempty"`

		// The number of snapshots to keep beyond the current snapshot.
		KeepOldSnapshots *uint64 `json:"KeepOldSnapshots,omitempty"`

		// The number of log entries to keep around to sync up slow followers
		// after a snapshot is created.
		LogEntriesForSlowFollowers *uint64 `json:"LogEntriesForSlowFollowers,omitempty"`

		// The number of log entries between snapshots.
		SnapshotInterval *uint64 `json:"SnapshotInterval,omitempty"`
	} `json:"Raft,omitempty"`

	// Defaults for creating tasks in this cluster.
	TaskDefaults *struct {
		// The log driver to use for tasks created in the orchestrator if
		// unspecified by a service.
		//
		// Updating this value only affects new tasks. Existing tasks continue
		// to use their previously configured log driver until recreated.
		LogDriver *struct {
			// The log driver to use as a default for new tasks.
			Name *string `json:"Name,omitempty"`

			// Driver-specific options for the selectd log driver, specified
			// as key/value pairs.
			Options *SwarmSpec_TaskDefaults_LogDriver_Options `json:"Options,omitempty"`
		} `json:"LogDriver,omitempty"`
	} `json:"TaskDefaults,omitempty"`
}

// An object with key/value pairs that are interpreted as
// protocol-specific options for the external CA driver.
type SwarmSpec_CAConfig_ExternalCAs_Options struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Protocol for communication with the external CA (currently
// only `cfssl` is supported).
type SwarmSpecCAConfigExternalCAsProtocol string

// User-defined key/value metadata.
type SwarmSpec_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Driver-specific options for the selectd log driver, specified
// as key/value pairs.
type SwarmSpec_TaskDefaults_LogDriver_Options struct {
	AdditionalProperties map[string]string `json:"-"`
}

// SystemInfo defines model for SystemInfo.
type SystemInfo struct {
	// Hardware architecture of the host, as returned by the Go runtime
	// (`GOARCH`).
	//
	// A full list of possible values can be found in the [Go documentation](https://golang.org/doc/install/source#environment).
	Architecture *string `json:"Architecture,omitempty"`

	// Indicates if `bridge-nf-call-ip6tables` is available on the host.
	BridgeNfIp6tables *bool `json:"BridgeNfIp6tables,omitempty"`

	// Indicates if `bridge-nf-call-iptables` is available on the host.
	BridgeNfIptables *bool `json:"BridgeNfIptables,omitempty"`

	// Indicates if CPUsets (cpuset.cpus, cpuset.mems) are supported by the host.
	//
	// See [cpuset(7)](https://www.kernel.org/doc/Documentation/cgroup-v1/cpusets.txt)
	CPUSet *bool `json:"CPUSet,omitempty"`

	// Indicates if CPU Shares limiting is supported by the host.
	CPUShares *bool `json:"CPUShares,omitempty"`

	// The driver to use for managing cgroups.
	CgroupDriver *SystemInfoCgroupDriver `json:"CgroupDriver,omitempty"`

	// The version of the cgroup.
	CgroupVersion *SystemInfoCgroupVersion `json:"CgroupVersion,omitempty"`

	// The network endpoint that the Engine advertises for the purpose of
	// node discovery. ClusterAdvertise is a `host:port` combination on which
	// the daemon is reachable by other hosts.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when using standalone Swarm
	// > mode, and overlay networking using an external k/v store. Overlay
	// > networks with Swarm mode enabled use the built-in raft store, and
	// > this field will be empty.
	ClusterAdvertise *string `json:"ClusterAdvertise,omitempty"`

	// URL of the distributed storage backend.
	//
	//
	// The storage backend is used for multihost networking (to store
	// network and endpoint information) and by the node discovery mechanism.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when using standalone Swarm
	// > mode, and overlay networking using an external k/v store. Overlay
	// > networks with Swarm mode enabled use the built-in raft store, and
	// > this field will be empty.
	ClusterStore *string `json:"ClusterStore,omitempty"`

	// Commit holds the Git-commit (SHA1) that a binary was built from, as
	// reported in the version-string of external tools, such as `containerd`,
	// or `runC`.
	ContainerdCommit *Commit `json:"ContainerdCommit,omitempty"`

	// Total number of containers on the host.
	Containers *int `json:"Containers,omitempty"`

	// Number of containers with status `"paused"`.
	ContainersPaused *int `json:"ContainersPaused,omitempty"`

	// Number of containers with status `"running"`.
	ContainersRunning *int `json:"ContainersRunning,omitempty"`

	// Number of containers with status `"stopped"`.
	ContainersStopped *int `json:"ContainersStopped,omitempty"`

	// Indicates if CPU CFS(Completely Fair Scheduler) period is supported by
	// the host.
	CpuCfsPeriod *bool `json:"CpuCfsPeriod,omitempty"`

	// Indicates if CPU CFS(Completely Fair Scheduler) quota is supported by
	// the host.
	CpuCfsQuota *bool `json:"CpuCfsQuota,omitempty"`

	// Indicates if the daemon is running in debug-mode / with debug-level
	// logging enabled.
	Debug *bool `json:"Debug,omitempty"`

	// List of custom default address pools for local networks, which can be
	// specified in the daemon.json file or dockerd option.
	//
	// Example: a Base "10.10.0.0/16" with Size 24 will define the set of 256
	// 10.10.[0-255].0/24 address pools.
	DefaultAddressPools *[]struct {
		// The network address in CIDR format
		Base *string `json:"Base,omitempty"`

		// The network pool size
		Size *int `json:"Size,omitempty"`
	} `json:"DefaultAddressPools,omitempty"`

	// Name of the default OCI runtime that is used when starting containers.
	//
	// The default can be overridden per-container at create time.
	DefaultRuntime *string `json:"DefaultRuntime,omitempty"`

	// Root directory of persistent Docker state.
	//
	// Defaults to `/var/lib/docker` on Linux, and `C:\ProgramData\docker`
	// on Windows.
	DockerRootDir *string `json:"DockerRootDir,omitempty"`

	// Name of the storage driver in use.
	Driver *string `json:"Driver,omitempty"`

	// Information specific to the storage driver, provided as
	// "label" / "value" pairs.
	//
	// This information is provided by the storage driver, and formatted
	// in a way consistent with the output of `docker info` on the command
	// line.
	//
	// <p><br /></p>
	//
	// > **Note**: The information returned in this field, including the
	// > formatting of values and labels, should not be considered stable,
	// > and may change without notice.
	DriverStatus *[][]string `json:"DriverStatus,omitempty"`

	// Indicates if experimental features are enabled on the daemon.
	ExperimentalBuild *bool `json:"ExperimentalBuild,omitempty"`

	// User-defined resources can be either Integer resources (e.g, `SSD=3`) or
	// String resources (e.g, `GPU=UUID1`).
	GenericResources *GenericResources `json:"GenericResources,omitempty"`

	// HTTP-proxy configured for the daemon. This value is obtained from the
	// [`HTTP_PROXY`](https://www.gnu.org/software/wget/manual/html_node/Proxies.html) environment variable.
	// Credentials ([user info component](https://tools.ietf.org/html/rfc3986#section-3.2.1)) in the proxy URL
	// are masked in the API response.
	//
	// Containers do not automatically inherit this configuration.
	HttpProxy *string `json:"HttpProxy,omitempty"`

	// HTTPS-proxy configured for the daemon. This value is obtained from the
	// [`HTTPS_PROXY`](https://www.gnu.org/software/wget/manual/html_node/Proxies.html) environment variable.
	// Credentials ([user info component](https://tools.ietf.org/html/rfc3986#section-3.2.1)) in the proxy URL
	// are masked in the API response.
	//
	// Containers do not automatically inherit this configuration.
	HttpsProxy *string `json:"HttpsProxy,omitempty"`

	// Unique identifier of the daemon.
	//
	// <p><br /></p>
	//
	// > **Note**: The format of the ID itself is not part of the API, and
	// > should not be considered stable.
	ID *string `json:"ID,omitempty"`

	// Indicates IPv4 forwarding is enabled.
	IPv4Forwarding *bool `json:"IPv4Forwarding,omitempty"`

	// Total number of images on the host.
	//
	// Both _tagged_ and _untagged_ (dangling) images are counted.
	Images *int `json:"Images,omitempty"`

	// Address / URL of the index server that is used for image search,
	// and as a default for user authentication for Docker Hub and Docker Cloud.
	IndexServerAddress *string `json:"IndexServerAddress,omitempty"`

	// Name and, optional, path of the `docker-init` binary.
	//
	// If the path is omitted, the daemon searches the host's `$PATH` for the
	// binary and uses the first result.
	InitBinary *string `json:"InitBinary,omitempty"`

	// Commit holds the Git-commit (SHA1) that a binary was built from, as
	// reported in the version-string of external tools, such as `containerd`,
	// or `runC`.
	InitCommit *Commit `json:"InitCommit,omitempty"`

	// Represents the isolation technology to use as a default for containers.
	// The supported values are platform-specific.
	//
	// If no isolation value is specified on daemon start, on Windows client,
	// the default is `hyperv`, and on Windows server, the default is `process`.
	//
	// This option is currently not used on other platforms.
	Isolation *SystemInfoIsolation `json:"Isolation,omitempty"`

	// Indicates if the host has kernel memory limit support enabled.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is deprecated as the kernel 5.4 deprecated
	// > `kmem.limit_in_bytes`.
	KernelMemory *bool `json:"KernelMemory,omitempty"`

	// Kernel version of the host.
	//
	// On Linux, this information obtained from `uname`. On Windows this
	// information is queried from the <kbd>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\</kbd>
	// registry value, for example _"10.0 14393 (14393.1198.amd64fre.rs1_release_sec.170427-1353)"_.
	KernelVersion *string `json:"KernelVersion,omitempty"`

	// User-defined labels (key/value metadata) as set on the daemon.
	//
	// <p><br /></p>
	//
	// > **Note**: When part of a Swarm, nodes can both have _daemon_ labels,
	// > set through the daemon configuration, and _node_ labels, set from a
	// > manager node in the Swarm. Node labels are not included in this
	// > field. Node labels can be retrieved using the `/nodes/(id)` endpoint
	// > on a manager node in the Swarm.
	Labels *[]string `json:"Labels,omitempty"`

	// Indicates if live restore is enabled.
	//
	// If enabled, containers are kept running when the daemon is shutdown
	// or upon daemon start if running containers are detected.
	LiveRestoreEnabled *bool `json:"LiveRestoreEnabled,omitempty"`

	// The logging driver to use as a default for new containers.
	LoggingDriver *string `json:"LoggingDriver,omitempty"`

	// Total amount of physical memory available on the host, in bytes.
	MemTotal *int64 `json:"MemTotal,omitempty"`

	// Indicates if the host has memory limit support enabled.
	MemoryLimit *bool `json:"MemoryLimit,omitempty"`

	// The number of logical CPUs usable by the daemon.
	//
	// The number of available CPUs is checked by querying the operating
	// system when the daemon starts. Changes to operating system CPU
	// allocation after the daemon is started are not reflected.
	NCPU *int `json:"NCPU,omitempty"`

	// Number of event listeners subscribed.
	NEventsListener *int `json:"NEventsListener,omitempty"`

	// The total number of file Descriptors in use by the daemon process.
	//
	// This information is only returned if debug-mode is enabled.
	NFd *int `json:"NFd,omitempty"`

	// The  number of goroutines that currently exist.
	//
	// This information is only returned if debug-mode is enabled.
	NGoroutines *int `json:"NGoroutines,omitempty"`

	// Hostname of the host.
	Name *string `json:"Name,omitempty"`

	// Comma-separated list of domain extensions for which no proxy should be
	// used. This value is obtained from the [`NO_PROXY`](https://www.gnu.org/software/wget/manual/html_node/Proxies.html)
	// environment variable.
	//
	// Containers do not automatically inherit this configuration.
	NoProxy *string `json:"NoProxy,omitempty"`

	// Generic type of the operating system of the host, as returned by the
	// Go runtime (`GOOS`).
	//
	// Currently returned values are "linux" and "windows". A full list of
	// possible values can be found in the [Go documentation](https://golang.org/doc/install/source#environment).
	OSType *string `json:"OSType,omitempty"`

	// Version of the host's operating system
	//
	// <p><br /></p>
	//
	// > **Note**: The information returned in this field, including its
	// > very existence, and the formatting of values, should not be considered
	// > stable, and may change without notice.
	OSVersion *string `json:"OSVersion,omitempty"`

	// Indicates if OOM killer disable is supported on the host.
	OomKillDisable *bool `json:"OomKillDisable,omitempty"`

	// Name of the host's operating system, for example: "Ubuntu 16.04.2 LTS"
	// or "Windows Server 2016 Datacenter"
	OperatingSystem *string `json:"OperatingSystem,omitempty"`

	// Indicates if the host kernel has PID limit support enabled.
	PidsLimit *bool `json:"PidsLimit,omitempty"`

	// Available plugins per type.
	//
	// <p><br /></p>
	//
	// > **Note**: Only unmanaged (V1) plugins are included in this list.
	// > V1 plugins are "lazily" loaded, and are not returned in this list
	// > if there is no resource using the plugin.
	Plugins *PluginsInfo `json:"Plugins,omitempty"`

	// Reports a summary of the product license on the daemon.
	//
	// If a commercial license has been applied to the daemon, information
	// such as number of nodes, and expiration are included.
	ProductLicense *string `json:"ProductLicense,omitempty"`

	// RegistryServiceConfig stores daemon registry services configuration.
	RegistryConfig *RegistryServiceConfig `json:"RegistryConfig"`

	// Commit holds the Git-commit (SHA1) that a binary was built from, as
	// reported in the version-string of external tools, such as `containerd`,
	// or `runC`.
	RuncCommit *Commit `json:"RuncCommit,omitempty"`

	// List of [OCI compliant](https://github.com/opencontainers/runtime-spec)
	// runtimes configured on the daemon. Keys hold the "name" used to
	// reference the runtime.
	//
	// The Docker daemon relies on an OCI compliant runtime (invoked via the
	// `containerd` daemon) as its interface to the Linux kernel namespaces,
	// cgroups, and SELinux.
	//
	// The default runtime is `runc`, and automatically configured. Additional
	// runtimes can be configured by the user and will be listed here.
	Runtimes *SystemInfo_Runtimes `json:"Runtimes,omitempty"`

	// List of security features that are enabled on the daemon, such as
	// apparmor, seccomp, SELinux, user-namespaces (userns), and rootless.
	//
	// Additional configuration options for each security feature may
	// be present, and are included as a comma-separated list of key/value
	// pairs.
	SecurityOptions *[]string `json:"SecurityOptions,omitempty"`

	// Version string of the daemon.
	//
	// > **Note**: the [standalone Swarm API](/swarm/swarm-api/)
	// > returns the Swarm version instead of the daemon  version, for example
	// > `swarm/1.2.8`.
	ServerVersion *string `json:"ServerVersion,omitempty"`

	// Indicates if the host has memory swap limit support enabled.
	SwapLimit *bool `json:"SwapLimit,omitempty"`

	// Represents generic information about swarm.
	Swarm *SwarmInfo `json:"Swarm,omitempty"`

	// Current system-time in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt)
	// format with nano-seconds.
	SystemTime *string `json:"SystemTime,omitempty"`

	// List of warnings / informational messages about missing features, or
	// issues related to the daemon configuration.
	//
	// These messages can be printed by the client as information to the user.
	Warnings *[]string `json:"Warnings,omitempty"`
}

// The driver to use for managing cgroups.
type SystemInfoCgroupDriver string

// The version of the cgroup.
type SystemInfoCgroupVersion string

// Represents the isolation technology to use as a default for containers.
// The supported values are platform-specific.
//
// If no isolation value is specified on daemon start, on Windows client,
// the default is `hyperv`, and on Windows server, the default is `process`.
//
// This option is currently not used on other platforms.
type SystemInfoIsolation string

// List of [OCI compliant](https://github.com/opencontainers/runtime-spec)
// runtimes configured on the daemon. Keys hold the "name" used to
// reference the runtime.
//
// The Docker daemon relies on an OCI compliant runtime (invoked via the
// `containerd` daemon) as its interface to the Linux kernel namespaces,
// cgroups, and SELinux.
//
// The default runtime is `runc`, and automatically configured. Additional
// runtimes can be configured by the user and will be listed here.
type SystemInfo_Runtimes struct {
	AdditionalProperties map[string]Runtime `json:"-"`
}

// Response of Engine API: GET "/version"
type SystemVersion struct {
	// The default (and highest) API version that is supported by the daemon
	ApiVersion *string `json:"ApiVersion,omitempty"`

	// The architecture that the daemon is running on
	Arch *string `json:"Arch,omitempty"`

	// The date and time that the daemon was compiled.
	BuildTime *string `json:"BuildTime,omitempty"`

	// Information about system components
	Components *[]struct {
		// Key/value pairs of strings with additional information about the
		// component. These values are intended for informational purposes
		// only, and their content is not defined, and not part of the API
		// specification.
		//
		// These messages can be printed by the client as information to the user.
		Details *map[string]interface{} `json:"Details"`

		// Name of the component
		Name string `json:"Name"`

		// Version of the component
		Version string `json:"Version"`
	} `json:"Components,omitempty"`

	// Indicates if the daemon is started with experimental features enabled.
	//
	// This field is omitted when empty / false.
	Experimental *bool `json:"Experimental,omitempty"`

	// The Git commit of the source code that was used to build the daemon
	GitCommit *string `json:"GitCommit,omitempty"`

	// The version Go used to compile the daemon, and the version of the Go
	// runtime in use.
	GoVersion *string `json:"GoVersion,omitempty"`

	// The kernel version (`uname -r`) that the daemon is running on.
	//
	// This field is omitted when empty.
	KernelVersion *string `json:"KernelVersion,omitempty"`

	// The minimum API version that is supported by the daemon
	MinAPIVersion *string `json:"MinAPIVersion,omitempty"`

	// The operating system that the daemon is running on ("linux" or "windows")
	Os       *string `json:"Os,omitempty"`
	Platform *struct {
		Name string `json:"Name"`
	} `json:"Platform,omitempty"`

	// The version of the daemon
	Version *string `json:"Version,omitempty"`
}

// Information about the issuer of leaf TLS certificates and the trusted root
// CA certificate.
type TLSInfo struct {
	// The base64-url-safe-encoded raw public key bytes of the issuer.
	CertIssuerPublicKey *string `json:"CertIssuerPublicKey,omitempty"`

	// The base64-url-safe-encoded raw subject bytes of the issuer.
	CertIssuerSubject *string `json:"CertIssuerSubject,omitempty"`

	// The root CA certificate(s) that are used to validate leaf TLS
	// certificates.
	TrustRoot *string `json:"TrustRoot,omitempty"`
}

// Task defines model for Task.
type Task struct {
	// User-defined resources can be either Integer resources (e.g, `SSD=3`) or
	// String resources (e.g, `GPU=UUID1`).
	AssignedGenericResources *GenericResources `json:"AssignedGenericResources,omitempty"`
	CreatedAt                *string           `json:"CreatedAt,omitempty"`
	DesiredState             *TaskState        `json:"DesiredState,omitempty"`

	// The ID of the task.
	ID *string `json:"ID,omitempty"`

	// The version number of the object such as node, service, etc. This is needed
	// to avoid conflicting writes. The client must send the version number along
	// with the modified specification when updating these objects.
	//
	// This approach ensures safe concurrency and determinism in that the change
	// on the object may not be applied if the version number has changed from the
	// last read. In other words, if two update requests specify the same base
	// version, only one of the requests can succeed. As a result, two separate
	// update requests that happen at the same time will not unintentionally
	// overwrite each other.
	JobIteration *ObjectVersion `json:"JobIteration,omitempty"`

	// User-defined key/value metadata.
	Labels *Task_Labels `json:"Labels,omitempty"`

	// Name of the task.
	Name *string `json:"Name,omitempty"`

	// The ID of the node that this task is on.
	NodeID *string `json:"NodeID,omitempty"`

	// The ID of the service this task is part of.
	ServiceID *string `json:"ServiceID,omitempty"`
	Slot      *int    `json:"Slot,omitempty"`

	// User modifiable task configuration.
	Spec   *TaskSpec `json:"Spec,omitempty"`
	Status *struct {
		ContainerStatus *struct {
			ContainerID *string `json:"ContainerID,omitempty"`
			ExitCode    *int    `json:"ExitCode,omitempty"`
			PID         *int    `json:"PID,omitempty"`
		} `json:"ContainerStatus,omitempty"`
		Err       *string    `json:"Err,omitempty"`
		Message   *string    `json:"Message,omitempty"`
		State     *TaskState `json:"State,omitempty"`
		Timestamp *string    `json:"Timestamp,omitempty"`
	} `json:"Status,omitempty"`
	UpdatedAt *string `json:"UpdatedAt,omitempty"`

	// The version number of the object such as node, service, etc. This is needed
	// to avoid conflicting writes. The client must send the version number along
	// with the modified specification when updating these objects.
	//
	// This approach ensures safe concurrency and determinism in that the change
	// on the object may not be applied if the version number has changed from the
	// last read. In other words, if two update requests specify the same base
	// version, only one of the requests can succeed. As a result, two separate
	// update requests that happen at the same time will not unintentionally
	// overwrite each other.
	Version *ObjectVersion `json:"Version,omitempty"`
}

// User-defined key/value metadata.
type Task_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// User modifiable task configuration.
type TaskSpec struct {
	// Container spec for the service.
	//
	// <p><br /></p>
	//
	// > **Note**: ContainerSpec, NetworkAttachmentSpec, and PluginSpec are
	// > mutually exclusive. PluginSpec is only used when the Runtime field
	// > is set to `plugin`. NetworkAttachmentSpec is used when the Runtime
	// > field is set to `attachment`.
	ContainerSpec *struct {
		// Arguments to the command.
		Args *[]string `json:"Args,omitempty"`

		// A list of kernel capabilities to add to the default set
		// for the container.
		CapabilityAdd *[]string `json:"CapabilityAdd,omitempty"`

		// A list of kernel capabilities to drop from the default set
		// for the container.
		CapabilityDrop *[]string `json:"CapabilityDrop,omitempty"`

		// The command to be run in the image.
		Command *[]string `json:"Command,omitempty"`

		// Configs contains references to zero or more configs that will be
		// exposed to the service.
		Configs *[]struct {
			// ConfigID represents the ID of the specific config that we're
			// referencing.
			ConfigID *string `json:"ConfigID,omitempty"`

			// ConfigName is the name of the config that this references,
			// but this is just provided for lookup/display purposes. The
			// config in the reference will be identified by its ID.
			ConfigName *string `json:"ConfigName,omitempty"`

			// File represents a specific target that is backed by a file.
			//
			// <p><br /><p>
			//
			// > **Note**: `Configs.File` and `Configs.Runtime` are mutually exclusive
			File *struct {
				// GID represents the file GID.
				GID *string `json:"GID,omitempty"`

				// Mode represents the FileMode of the file.
				Mode *uint32 `json:"Mode,omitempty"`

				// Name represents the final filename in the filesystem.
				Name *string `json:"Name,omitempty"`

				// UID represents the file UID.
				UID *string `json:"UID,omitempty"`
			} `json:"File,omitempty"`

			// Runtime represents a target that is not mounted into the
			// container but is used by the task
			//
			// <p><br /><p>
			//
			// > **Note**: `Configs.File` and `Configs.Runtime` are mutually
			// > exclusive
			Runtime *map[string]interface{} `json:"Runtime,omitempty"`
		} `json:"Configs,omitempty"`

		// Specification for DNS related configurations in resolver configuration
		// file (`resolv.conf`).
		DNSConfig *struct {
			// The IP addresses of the name servers.
			Nameservers *[]string `json:"Nameservers,omitempty"`

			// A list of internal resolver variables to be modified (e.g.,
			// `debug`, `ndots:3`, etc.).
			Options *[]string `json:"Options,omitempty"`

			// A search list for host-name lookup.
			Search *[]string `json:"Search,omitempty"`
		} `json:"DNSConfig,omitempty"`

		// The working directory for commands to run in.
		Dir *string `json:"Dir,omitempty"`

		// A list of environment variables in the form `VAR=value`.
		Env *[]string `json:"Env,omitempty"`

		// A list of additional groups that the container process will run as.
		Groups *[]string `json:"Groups,omitempty"`

		// A test to perform to check that the container is healthy.
		HealthCheck *HealthConfig `json:"HealthCheck,omitempty"`

		// The hostname to use for the container, as a valid
		// [RFC 1123](https://tools.ietf.org/html/rfc1123) hostname.
		Hostname *string `json:"Hostname,omitempty"`

		// A list of hostname/IP mappings to add to the container's `hosts`
		// file. The format of extra hosts is specified in the
		// [hosts(5)](http://man7.org/linux/man-pages/man5/hosts.5.html)
		// man page:
		//
		//     IP_address canonical_hostname [aliases...]
		Hosts *[]string `json:"Hosts,omitempty"`

		// The image name to use for the container
		Image *string `json:"Image,omitempty"`

		// Run an init inside the container that forwards signals and reaps
		// processes. This field is omitted if empty, and the default (as
		// configured on the daemon) is used.
		Init *bool `json:"Init"`

		// Isolation technology of the containers running the service.
		// (Windows only)
		Isolation *TaskSpecContainerSpecIsolation `json:"Isolation,omitempty"`

		// User-defined key/value data.
		Labels *TaskSpec_ContainerSpec_Labels `json:"Labels,omitempty"`

		// Specification for mounts to be added to containers created as part
		// of the service.
		Mounts *[]Mount `json:"Mounts,omitempty"`

		// Open `stdin`
		OpenStdin *bool `json:"OpenStdin,omitempty"`

		// Security options for the container
		Privileges *struct {
			// CredentialSpec for managed service account (Windows only)
			CredentialSpec *struct {
				// Load credential spec from a Swarm Config with the given ID.
				// The specified config must also be present in the Configs
				// field with the Runtime property set.
				//
				// <p><br /></p>
				//
				//
				// > **Note**: `CredentialSpec.File`, `CredentialSpec.Registry`,
				// > and `CredentialSpec.Config` are mutually exclusive.
				Config *string `json:"Config,omitempty"`

				// Load credential spec from this file. The file is read by
				// the daemon, and must be present in the `CredentialSpecs`
				// subdirectory in the docker data directory, which defaults
				// to `C:\ProgramData\Docker\` on Windows.
				//
				// For example, specifying `spec.json` loads
				// `C:\ProgramData\Docker\CredentialSpecs\spec.json`.
				//
				// <p><br /></p>
				//
				// > **Note**: `CredentialSpec.File`, `CredentialSpec.Registry`,
				// > and `CredentialSpec.Config` are mutually exclusive.
				File *string `json:"File,omitempty"`

				// Load credential spec from this value in the Windows
				// registry. The specified registry value must be located in:
				//
				// `HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Virtualization\Containers\CredentialSpecs`
				//
				// <p><br /></p>
				//
				//
				// > **Note**: `CredentialSpec.File`, `CredentialSpec.Registry`,
				// > and `CredentialSpec.Config` are mutually exclusive.
				Registry *string `json:"Registry,omitempty"`
			} `json:"CredentialSpec,omitempty"`

			// SELinux labels of the container
			SELinuxContext *struct {
				// Disable SELinux
				Disable *bool `json:"Disable,omitempty"`

				// SELinux level label
				Level *string `json:"Level,omitempty"`

				// SELinux role label
				Role *string `json:"Role,omitempty"`

				// SELinux type label
				Type *string `json:"Type,omitempty"`

				// SELinux user label
				User *string `json:"User,omitempty"`
			} `json:"SELinuxContext,omitempty"`
		} `json:"Privileges,omitempty"`

		// Mount the container's root filesystem as read only.
		ReadOnly *bool `json:"ReadOnly,omitempty"`

		// Secrets contains references to zero or more secrets that will be
		// exposed to the service.
		Secrets *[]struct {
			// File represents a specific target that is backed by a file.
			File *struct {
				// GID represents the file GID.
				GID *string `json:"GID,omitempty"`

				// Mode represents the FileMode of the file.
				Mode *uint32 `json:"Mode,omitempty"`

				// Name represents the final filename in the filesystem.
				Name *string `json:"Name,omitempty"`

				// UID represents the file UID.
				UID *string `json:"UID,omitempty"`
			} `json:"File,omitempty"`

			// SecretID represents the ID of the specific secret that we're
			// referencing.
			SecretID *string `json:"SecretID,omitempty"`

			// SecretName is the name of the secret that this references,
			// but this is just provided for lookup/display purposes. The
			// secret in the reference will be identified by its ID.
			SecretName *string `json:"SecretName,omitempty"`
		} `json:"Secrets,omitempty"`

		// Amount of time to wait for the container to terminate before
		// forcefully killing it.
		StopGracePeriod *int64 `json:"StopGracePeriod,omitempty"`

		// Signal to stop the container.
		StopSignal *string `json:"StopSignal,omitempty"`

		// Set kernel namedspaced parameters (sysctls) in the container.
		// The Sysctls option on services accepts the same sysctls as the
		// are supported on containers. Note that while the same sysctls are
		// supported, no guarantees or checks are made about their
		// suitability for a clustered environment, and it's up to the user
		// to determine whether a given sysctl will work properly in a
		// Service.
		Sysctls *TaskSpec_ContainerSpec_Sysctls `json:"Sysctls,omitempty"`

		// Whether a pseudo-TTY should be allocated.
		TTY *bool `json:"TTY,omitempty"`

		// A list of resource limits to set in the container. For example: `{"Name": "nofile", "Soft": 1024, "Hard": 2048}`"
		Ulimits *[]struct {
			// Hard limit
			Hard *int `json:"Hard,omitempty"`

			// Name of ulimit
			Name *string `json:"Name,omitempty"`

			// Soft limit
			Soft *int `json:"Soft,omitempty"`
		} `json:"Ulimits,omitempty"`

		// The user inside the container.
		User *string `json:"User,omitempty"`
	} `json:"ContainerSpec,omitempty"`

	// A counter that triggers an update even if no relevant parameters have
	// been changed.
	ForceUpdate *int `json:"ForceUpdate,omitempty"`

	// Specifies the log driver to use for tasks created from this spec. If
	// not present, the default one for the swarm will be used, finally
	// falling back to the engine default if not specified.
	LogDriver *struct {
		Name    *string                     `json:"Name,omitempty"`
		Options *TaskSpec_LogDriver_Options `json:"Options,omitempty"`
	} `json:"LogDriver,omitempty"`

	// Read-only spec type for non-swarm containers attached to swarm overlay
	// networks.
	//
	// <p><br /></p>
	//
	// > **Note**: ContainerSpec, NetworkAttachmentSpec, and PluginSpec are
	// > mutually exclusive. PluginSpec is only used when the Runtime field
	// > is set to `plugin`. NetworkAttachmentSpec is used when the Runtime
	// > field is set to `attachment`.
	NetworkAttachmentSpec *struct {
		// ID of the container represented by this task
		ContainerID *string `json:"ContainerID,omitempty"`
	} `json:"NetworkAttachmentSpec,omitempty"`

	// Specifies which networks the service should attach to.
	Networks  *[]NetworkAttachmentConfig `json:"Networks,omitempty"`
	Placement *struct {
		// An array of constraint expressions to limit the set of nodes where
		// a task can be scheduled. Constraint expressions can either use a
		// _match_ (`==`) or _exclude_ (`!=`) rule. Multiple constraints find
		// nodes that satisfy every expression (AND match). Constraints can
		// match node or Docker Engine labels as follows:
		//
		// node attribute       | matches                        | example
		// ---------------------|--------------------------------|-----------------------------------------------
		// `node.id`            | Node ID                        | `node.id==2ivku8v2gvtg4`
		// `node.hostname`      | Node hostname                  | `node.hostname!=node-2`
		// `node.role`          | Node role (`manager`/`worker`) | `node.role==manager`
		// `node.platform.os`   | Node operating system          | `node.platform.os==windows`
		// `node.platform.arch` | Node architecture              | `node.platform.arch==x86_64`
		// `node.labels`        | User-defined node labels       | `node.labels.security==high`
		// `engine.labels`      | Docker Engine's labels         | `engine.labels.operatingsystem==ubuntu-14.04`
		//
		// `engine.labels` apply to Docker Engine labels like operating system,
		// drivers, etc. Swarm administrators add `node.labels` for operational
		// purposes by using the [`node update endpoint`](#operation/NodeUpdate).
		Constraints *[]string `json:"Constraints,omitempty"`

		// Maximum number of replicas for per node (default value is 0, which
		// is unlimited)
		MaxReplicas *int64 `json:"MaxReplicas,omitempty"`

		// Platforms stores all the platforms that the service's image can
		// run on. This field is used in the platform filter for scheduling.
		// If empty, then the platform filter is off, meaning there are no
		// scheduling restrictions.
		Platforms *[]Platform `json:"Platforms,omitempty"`

		// Preferences provide a way to make the scheduler aware of factors
		// such as topology. They are provided in order from highest to
		// lowest precedence.
		Preferences *[]struct {
			Spread *struct {
				// label descriptor, such as `engine.labels.az`.
				SpreadDescriptor *string `json:"SpreadDescriptor,omitempty"`
			} `json:"Spread,omitempty"`
		} `json:"Preferences,omitempty"`
	} `json:"Placement,omitempty"`

	// Plugin spec for the service.  *(Experimental release only.)*
	//
	// <p><br /></p>
	//
	// > **Note**: ContainerSpec, NetworkAttachmentSpec, and PluginSpec are
	// > mutually exclusive. PluginSpec is only used when the Runtime field
	// > is set to `plugin`. NetworkAttachmentSpec is used when the Runtime
	// > field is set to `attachment`.
	PluginSpec *struct {
		// Disable the plugin once scheduled.
		Disabled *bool `json:"Disabled,omitempty"`

		// The name or 'alias' to use for the plugin.
		Name            *string `json:"Name,omitempty"`
		PluginPrivilege *[]struct {
			Description *string   `json:"Description,omitempty"`
			Name        *string   `json:"Name,omitempty"`
			Value       *[]string `json:"Value,omitempty"`
		} `json:"PluginPrivilege,omitempty"`

		// The plugin image reference to use.
		Remote *string `json:"Remote,omitempty"`
	} `json:"PluginSpec,omitempty"`

	// Resource requirements which apply to each individual container created
	// as part of the service.
	Resources *struct {
		// An object describing a limit on resources which can be requested by a task.
		Limits *Limit `json:"Limits,omitempty"`

		// An object describing the resources which can be advertised by a node and
		// requested by a task.
		Reservation *ResourceObject `json:"Reservation,omitempty"`
	} `json:"Resources,omitempty"`

	// Specification for the restart policy which applies to containers
	// created as part of this service.
	RestartPolicy *struct {
		// Condition for restart.
		Condition *TaskSpecRestartPolicyCondition `json:"Condition,omitempty"`

		// Delay between restart attempts.
		Delay *int64 `json:"Delay,omitempty"`

		// Maximum attempts to restart a given container before giving up
		// (default value is 0, which is ignored).
		MaxAttempts *int64 `json:"MaxAttempts,omitempty"`

		// Windows is the time window used to evaluate the restart policy
		// (default value is 0, which is unbounded).
		Window *int64 `json:"Window,omitempty"`
	} `json:"RestartPolicy,omitempty"`

	// Runtime is the type of runtime specified for the task executor.
	Runtime *string `json:"Runtime,omitempty"`
}

// Isolation technology of the containers running the service.
// (Windows only)
type TaskSpecContainerSpecIsolation string

// User-defined key/value data.
type TaskSpec_ContainerSpec_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Set kernel namedspaced parameters (sysctls) in the container.
// The Sysctls option on services accepts the same sysctls as the
// are supported on containers. Note that while the same sysctls are
// supported, no guarantees or checks are made about their
// suitability for a clustered environment, and it's up to the user
// to determine whether a given sysctl will work properly in a
// Service.
type TaskSpec_ContainerSpec_Sysctls struct {
	AdditionalProperties map[string]string `json:"-"`
}

// TaskSpec_LogDriver_Options defines model for TaskSpec.LogDriver.Options.
type TaskSpec_LogDriver_Options struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Condition for restart.
type TaskSpecRestartPolicyCondition string

// TaskState defines model for TaskState.
type TaskState string

// ThrottleDevice defines model for ThrottleDevice.
type ThrottleDevice struct {
	// Device path
	Path *string `json:"Path,omitempty"`

	// Rate
	Rate *int64 `json:"Rate,omitempty"`
}

// Volume defines model for Volume.
type Volume struct {
	// Date/Time the volume was created.
	CreatedAt *string `json:"CreatedAt,omitempty"`

	// Name of the volume driver used by the volume.
	Driver string `json:"Driver"`

	// User-defined key/value metadata.
	Labels Volume_Labels `json:"Labels"`

	// Mount path of the volume on the host.
	Mountpoint string `json:"Mountpoint"`

	// Name of the volume.
	Name string `json:"Name"`

	// The driver specific options used when creating the volume.
	Options Volume_Options `json:"Options"`

	// The level at which the volume exists. Either `global` for cluster-wide,
	// or `local` for machine level.
	Scope VolumeScope `json:"Scope"`

	// Low-level details about the volume, provided by the volume driver.
	// Details are returned as a map with key/value pairs:
	// `{"key":"value","key2":"value2"}`.
	//
	// The `Status` field is optional, and is omitted if the volume driver
	// does not support this feature.
	Status *Volume_Status `json:"Status,omitempty"`

	// Usage details about the volume. This information is used by the
	// `GET /system/df` endpoint, and omitted in other endpoints.
	UsageData *struct {
		// The number of containers referencing this volume. This field
		// is set to `-1` if the reference-count is not available.
		RefCount int `json:"RefCount"`

		// Amount of disk space used by the volume (in bytes). This information
		// is only available for volumes created with the `"local"` volume
		// driver. For volumes created with other volume drivers, this field
		// is set to `-1` ("not available")
		Size int `json:"Size"`
	} `json:"UsageData"`
}

// User-defined key/value metadata.
type Volume_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// The driver specific options used when creating the volume.
type Volume_Options struct {
	AdditionalProperties map[string]string `json:"-"`
}

// The level at which the volume exists. Either `global` for cluster-wide,
// or `local` for machine level.
type VolumeScope string

// Low-level details about the volume, provided by the volume driver.
// Details are returned as a map with key/value pairs:
// `{"key":"value","key2":"value2"}`.
//
// The `Status` field is optional, and is omitted if the volume driver
// does not support this feature.
type Volume_Status struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// SystemAuthJSONBody defines parameters for SystemAuth.
type SystemAuthJSONBody AuthConfig

// ImageBuildParams defines parameters for ImageBuild.
type ImageBuildParams struct {
	// Path within the build context to the `Dockerfile`. This is ignored if `remote` is specified and points to an external `Dockerfile`.
	Dockerfile *string `json:"dockerfile,omitempty"`

	// A name and optional tag to apply to the image in the `name:tag` format. If you omit the tag the default `latest` value is assumed. You can provide several `t` parameters.
	T *string `json:"t,omitempty"`

	// Extra hosts to add to /etc/hosts
	Extrahosts *string `json:"extrahosts,omitempty"`

	// A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the files contents are placed into a file called `Dockerfile` and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the `dockerfile` parameter is also specified, there must be a file with the corresponding path inside the tarball.
	Remote *string `json:"remote,omitempty"`

	// Suppress verbose build output.
	Q *bool `json:"q,omitempty"`

	// Do not use the cache when building the image.
	Nocache *bool `json:"nocache,omitempty"`

	// JSON array of images used for build cache resolution.
	Cachefrom *string `json:"cachefrom,omitempty"`

	// Attempt to pull the image even if an older image exists locally.
	Pull *string `json:"pull,omitempty"`

	// Remove intermediate containers after a successful build.
	Rm *bool `json:"rm,omitempty"`

	// Always remove intermediate containers, even upon failure.
	Forcerm *bool `json:"forcerm,omitempty"`

	// Set memory limit for build.
	Memory *int `json:"memory,omitempty"`

	// Total memory (memory + swap). Set as `-1` to disable swap.
	Memswap *int `json:"memswap,omitempty"`

	// CPU shares (relative weight).
	Cpushares *int `json:"cpushares,omitempty"`

	// CPUs in which to allow execution (e.g., `0-3`, `0,1`).
	Cpusetcpus *string `json:"cpusetcpus,omitempty"`

	// The length of a CPU period in microseconds.
	Cpuperiod *int `json:"cpuperiod,omitempty"`

	// Microseconds of CPU time that the container can get in a CPU period.
	Cpuquota *int `json:"cpuquota,omitempty"`

	// JSON map of string pairs for build-time variables. Users pass these values at build-time. Docker uses the buildargs as the environment context for commands run via the `Dockerfile` RUN instruction, or for variable expansion in other `Dockerfile` instructions. This is not meant for passing secret values.
	//
	// For example, the build arg `FOO=bar` would become `{"FOO":"bar"}` in JSON. This would result in the query parameter `buildargs={"FOO":"bar"}`. Note that `{"FOO":"bar"}` should be URI component encoded.
	//
	// [Read more about the buildargs instruction.](/engine/reference/builder/#arg)
	Buildargs *string `json:"buildargs,omitempty"`

	// Size of `/dev/shm` in bytes. The size must be greater than 0. If omitted the system uses 64MB.
	Shmsize *int `json:"shmsize,omitempty"`

	// Squash the resulting images layers into a single layer. *(Experimental release only.)*
	Squash *bool `json:"squash,omitempty"`

	// Arbitrary key/value labels to set on the image, as a JSON map of string pairs.
	Labels *string `json:"labels,omitempty"`

	// Sets the networking mode for the run commands during build. Supported
	// standard values are: `bridge`, `host`, `none`, and `container:<name|id>`.
	// Any other value is taken as a custom network's name or ID to which this
	// container should connect to.
	Networkmode *string `json:"networkmode,omitempty"`

	// Platform in the format os[/arch[/variant]]
	Platform *string `json:"platform,omitempty"`

	// Target build stage
	Target *string `json:"target,omitempty"`

	// BuildKit output configuration
	Outputs     *string                      `json:"outputs,omitempty"`
	ContentType *ImageBuildParamsContentType `json:"Content-type,omitempty"`

	// This is a base64-encoded JSON object with auth configurations for multiple registries that a build may refer to.
	//
	// The key is a registry URL, and the value is an auth configuration object, [as described in the authentication section](#section/Authentication). For example:
	//
	// ```
	// {
	//   "docker.example.com": {
	//     "username": "janedoe",
	//     "password": "hunter2"
	//   },
	//   "https://index.docker.io/v1/": {
	//     "username": "mobydock",
	//     "password": "conta1n3rize14"
	//   }
	// }
	// ```
	//
	// Only the registry domain name (and port if not the default 443) are required. However, for legacy reasons, the Docker Hub registry must be specified with both a `https://` prefix and a `/v1/` suffix even though Docker will prefer to use the v2 registry API.
	XRegistryConfig *string `json:"X-Registry-Config,omitempty"`
}

// ImageBuildParamsContentType defines parameters for ImageBuild.
type ImageBuildParamsContentType string

// BuildPruneParams defines parameters for BuildPrune.
type BuildPruneParams struct {
	// Amount of disk space in bytes to keep for cache
	KeepStorage *int64 `json:"keep-storage,omitempty"`

	// Remove all types of build cache
	All *bool `json:"all,omitempty"`

	// A JSON encoded value of the filters (a `map[string][]string`) to
	// process on the list of build cache objects.
	//
	// Available filters:
	//
	// - `until=<duration>`: duration relative to daemon's time, during which build cache was not used, in Go's duration format (e.g., '24h')
	// - `id=<id>`
	// - `parent=<id>`
	// - `type=<string>`
	// - `description=<string>`
	// - `inuse`
	// - `shared`
	// - `private`
	Filters *string `json:"filters,omitempty"`
}

// ImageCommitJSONBody defines parameters for ImageCommit.
type ImageCommitJSONBody ContainerConfig

// ImageCommitParams defines parameters for ImageCommit.
type ImageCommitParams struct {
	// The ID or name of the container to commit
	Container *string `json:"container,omitempty"`

	// Repository name for the created image
	Repo *string `json:"repo,omitempty"`

	// Tag name for the create image
	Tag *string `json:"tag,omitempty"`

	// Commit message
	Comment *string `json:"comment,omitempty"`

	// Author of the image (e.g., `John Hannibal Smith <hannibal@a-team.com>`)
	Author *string `json:"author,omitempty"`

	// Whether to pause the container before committing
	Pause *bool `json:"pause,omitempty"`

	// `Dockerfile` instructions to apply while committing
	Changes *string `json:"changes,omitempty"`
}

// ConfigListParams defines parameters for ConfigList.
type ConfigListParams struct {
	// A JSON encoded value of the filters (a `map[string][]string`) to
	// process on the configs list.
	//
	// Available filters:
	//
	// - `id=<config id>`
	// - `label=<key> or label=<key>=value`
	// - `name=<config name>`
	// - `names=<config name>`
	Filters *string `json:"filters,omitempty"`
}

// ConfigCreateJSONBody defines parameters for ConfigCreate.
type ConfigCreateJSONBody struct {
	// Embedded struct due to allOf(#/components/schemas/ConfigSpec)
	ConfigSpec `yaml:",inline"`
	// Embedded fields due to inline allOf schema
}

// ConfigUpdateJSONBody defines parameters for ConfigUpdate.
type ConfigUpdateJSONBody ConfigSpec

// ConfigUpdateParams defines parameters for ConfigUpdate.
type ConfigUpdateParams struct {
	// The version number of the config object being updated. This is
	// required to avoid conflicting writes.
	Version int64 `json:"version"`
}

// ContainerCreateJSONBody defines parameters for ContainerCreate.
type ContainerCreateJSONBody struct {
	// Embedded struct due to allOf(#/components/schemas/ContainerConfig)
	ContainerConfig `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// Container configuration that depends on the host we are running on
	HostConfig *HostConfig `json:"HostConfig,omitempty"`

	// NetworkingConfig represents the container's networking configuration for
	// each of its interfaces.
	// It is used for the networking configs specified in the `docker create`
	// and `docker network connect` commands.
	NetworkingConfig *NetworkingConfig `json:"NetworkingConfig,omitempty"`
}

// ContainerCreateParams defines parameters for ContainerCreate.
type ContainerCreateParams struct {
	// Assign the specified name to the container. Must match
	// `/?[a-zA-Z0-9][a-zA-Z0-9_.-]+`.
	Name *string `json:"name,omitempty"`
}

// ContainerListParams defines parameters for ContainerList.
type ContainerListParams struct {
	// Return all containers. By default, only running containers are shown.
	All *bool `json:"all,omitempty"`

	// Return this number of most recently created containers, including
	// non-running ones.
	Limit *int `json:"limit,omitempty"`

	// Return the size of container as fields `SizeRw` and `SizeRootFs`.
	Size *bool `json:"size,omitempty"`

	// Filters to process on the container list, encoded as JSON (a
	// `map[string][]string`). For example, `{"status": ["paused"]}` will
	// only return paused containers.
	//
	// Available filters:
	//
	// - `ancestor`=(`<image-name>[:<tag>]`, `<image id>`, or `<image@digest>`)
	// - `before`=(`<container id>` or `<container name>`)
	// - `expose`=(`<port>[/<proto>]`|`<startport-endport>/[<proto>]`)
	// - `exited=<int>` containers with exit code of `<int>`
	// - `health`=(`starting`|`healthy`|`unhealthy`|`none`)
	// - `id=<ID>` a container's ID
	// - `isolation=`(`default`|`process`|`hyperv`) (Windows daemon only)
	// - `is-task=`(`true`|`false`)
	// - `label=key` or `label="key=value"` of a container label
	// - `name=<name>` a container's name
	// - `network`=(`<network id>` or `<network name>`)
	// - `publish`=(`<port>[/<proto>]`|`<startport-endport>/[<proto>]`)
	// - `since`=(`<container id>` or `<container name>`)
	// - `status=`(`created`|`restarting`|`running`|`removing`|`paused`|`exited`|`dead`)
	// - `volume`=(`<volume name>` or `<mount point destination>`)
	Filters *string `json:"filters,omitempty"`
}

// ContainerPruneParams defines parameters for ContainerPrune.
type ContainerPruneParams struct {
	// Filters to process on the prune list, encoded as JSON (a `map[string][]string`).
	//
	// Available filters:
	// - `until=<timestamp>` Prune containers created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machines time.
	// - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune containers with (or without, in case `label!=...` is used) the specified labels.
	Filters *string `json:"filters,omitempty"`
}

// ContainerDeleteParams defines parameters for ContainerDelete.
type ContainerDeleteParams struct {
	// Remove anonymous volumes associated with the container.
	V *bool `json:"v,omitempty"`

	// If the container is running, kill it before removing it.
	Force *bool `json:"force,omitempty"`

	// Remove the specified link associated with the container.
	Link *bool `json:"link,omitempty"`
}

// ContainerArchiveParams defines parameters for ContainerArchive.
type ContainerArchiveParams struct {
	// Resource in the containers filesystem to archive.
	Path string `json:"path"`
}

// ContainerArchiveInfoParams defines parameters for ContainerArchiveInfo.
type ContainerArchiveInfoParams struct {
	// Resource in the containers filesystem to archive.
	Path string `json:"path"`
}

// PutContainerArchiveParams defines parameters for PutContainerArchive.
type PutContainerArchiveParams struct {
	// Path to a directory in the container to extract the archives contents into.
	Path string `json:"path"`

	// If `1`, `true`, or `True` then it will be an error if unpacking the
	// given content would cause an existing directory to be replaced with
	// a non-directory and vice versa.
	NoOverwriteDirNonDir *string `json:"noOverwriteDirNonDir,omitempty"`

	// If `1`, `true`, then it will copy UID/GID maps to the dest file or
	// dir
	CopyUIDGID *string `json:"copyUIDGID,omitempty"`
}

// ContainerAttachParams defines parameters for ContainerAttach.
type ContainerAttachParams struct {
	// Override the key sequence for detaching a container.Format is a single
	// character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`,
	// `@`, `^`, `[`, `,` or `_`.
	DetachKeys *string `json:"detachKeys,omitempty"`

	// Replay previous logs from the container.
	//
	// This is useful for attaching to a container that has started and you
	// want to output everything since the container started.
	//
	// If `stream` is also enabled, once all the previous output has been
	// returned, it will seamlessly transition into streaming current
	// output.
	Logs *bool `json:"logs,omitempty"`

	// Stream attached streams from the time the request was made onwards.
	Stream *bool `json:"stream,omitempty"`

	// Attach to `stdin`
	Stdin *bool `json:"stdin,omitempty"`

	// Attach to `stdout`
	Stdout *bool `json:"stdout,omitempty"`

	// Attach to `stderr`
	Stderr *bool `json:"stderr,omitempty"`
}

// ContainerAttachWebsocketParams defines parameters for ContainerAttachWebsocket.
type ContainerAttachWebsocketParams struct {
	// Override the key sequence for detaching a container.Format is a single
	// character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`,
	// `@`, `^`, `[`, `,`, or `_`.
	DetachKeys *string `json:"detachKeys,omitempty"`

	// Return logs
	Logs *bool `json:"logs,omitempty"`

	// Return stream
	Stream *bool `json:"stream,omitempty"`

	// Attach to `stdin`
	Stdin *bool `json:"stdin,omitempty"`

	// Attach to `stdout`
	Stdout *bool `json:"stdout,omitempty"`

	// Attach to `stderr`
	Stderr *bool `json:"stderr,omitempty"`
}

// ContainerExecJSONBody defines parameters for ContainerExec.
type ContainerExecJSONBody struct {
	// Attach to `stderr` of the exec command.
	AttachStderr *bool `json:"AttachStderr,omitempty"`

	// Attach to `stdin` of the exec command.
	AttachStdin *bool `json:"AttachStdin,omitempty"`

	// Attach to `stdout` of the exec command.
	AttachStdout *bool `json:"AttachStdout,omitempty"`

	// Command to run, as a string or array of strings.
	Cmd *[]string `json:"Cmd,omitempty"`

	// Override the key sequence for detaching a container. Format is
	// a single character `[a-Z]` or `ctrl-<value>` where `<value>`
	// is one of: `a-z`, `@`, `^`, `[`, `,` or `_`.
	DetachKeys *string `json:"DetachKeys,omitempty"`

	// A list of environment variables in the form `["VAR=value", ...]`.
	Env *[]string `json:"Env,omitempty"`

	// Runs the exec process with extended privileges.
	Privileged *bool `json:"Privileged,omitempty"`

	// Allocate a pseudo-TTY.
	Tty *bool `json:"Tty,omitempty"`

	// The user, and optionally, group to run the exec process inside
	// the container. Format is one of: `user`, `user:group`, `uid`,
	// or `uid:gid`.
	User *string `json:"User,omitempty"`

	// The working directory for the exec process inside the container.
	WorkingDir *string `json:"WorkingDir,omitempty"`
}

// ContainerInspectParams defines parameters for ContainerInspect.
type ContainerInspectParams struct {
	// Return the size of container as fields `SizeRw` and `SizeRootFs`
	Size *bool `json:"size,omitempty"`
}

// ContainerKillParams defines parameters for ContainerKill.
type ContainerKillParams struct {
	// Signal to send to the container as an integer or string (e.g. `SIGINT`)
	Signal *string `json:"signal,omitempty"`
}

// ContainerLogsParams defines parameters for ContainerLogs.
type ContainerLogsParams struct {
	// Keep connection after returning logs.
	Follow *bool `json:"follow,omitempty"`

	// Return logs from `stdout`
	Stdout *bool `json:"stdout,omitempty"`

	// Return logs from `stderr`
	Stderr *bool `json:"stderr,omitempty"`

	// Only return logs since this time, as a UNIX timestamp
	Since *int `json:"since,omitempty"`

	// Only return logs before this time, as a UNIX timestamp
	Until *int `json:"until,omitempty"`

	// Add timestamps to every log line
	Timestamps *bool `json:"timestamps,omitempty"`

	// Only return this number of log lines from the end of the logs.
	// Specify as an integer or `all` to output all log lines.
	Tail *string `json:"tail,omitempty"`
}

// ContainerRenameParams defines parameters for ContainerRename.
type ContainerRenameParams struct {
	// New name for the container
	Name string `json:"name"`
}

// ContainerResizeParams defines parameters for ContainerResize.
type ContainerResizeParams struct {
	// Height of the TTY session in characters
	H *int `json:"h,omitempty"`

	// Width of the TTY session in characters
	W *int `json:"w,omitempty"`
}

// ContainerRestartParams defines parameters for ContainerRestart.
type ContainerRestartParams struct {
	// Number of seconds to wait before killing the container
	T *int `json:"t,omitempty"`
}

// ContainerStartParams defines parameters for ContainerStart.
type ContainerStartParams struct {
	// Override the key sequence for detaching a container. Format is a
	// single character `[a-Z]` or `ctrl-<value>` where `<value>` is one
	// of: `a-z`, `@`, `^`, `[`, `,` or `_`.
	DetachKeys *string `json:"detachKeys,omitempty"`
}

// ContainerStatsParams defines parameters for ContainerStats.
type ContainerStatsParams struct {
	// Stream the output. If false, the stats will be output once and then
	// it will disconnect.
	Stream *bool `json:"stream,omitempty"`

	// Only get a single stat instead of waiting for 2 cycles. Must be used
	// with `stream=false`.
	OneShot *bool `json:"one-shot,omitempty"`
}

// ContainerStopParams defines parameters for ContainerStop.
type ContainerStopParams struct {
	// Number of seconds to wait before killing the container
	T *int `json:"t,omitempty"`
}

// ContainerTopParams defines parameters for ContainerTop.
type ContainerTopParams struct {
	// The arguments to pass to `ps`. For example, `aux`
	PsArgs *string `json:"ps_args,omitempty"`
}

// ContainerUpdateJSONBody defines parameters for ContainerUpdate.
type ContainerUpdateJSONBody struct {
	// Embedded struct due to allOf(#/components/schemas/Resources)
	Resources `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// The behavior to apply when the container exits. The default is not to
	// restart.
	//
	// An ever increasing delay (double the previous delay, starting at 100ms) is
	// added before each restart to prevent flooding the server.
	RestartPolicy *RestartPolicy `json:"RestartPolicy,omitempty"`
}

// ContainerWaitParams defines parameters for ContainerWait.
type ContainerWaitParams struct {
	// Wait until a container state reaches the given condition, either
	// 'not-running' (default), 'next-exit', or 'removed'.
	Condition *string `json:"condition,omitempty"`
}

// SystemEventsParams defines parameters for SystemEvents.
type SystemEventsParams struct {
	// Show events created since this timestamp then stream new events.
	Since *string `json:"since,omitempty"`

	// Show events created until this timestamp then stop streaming.
	Until *string `json:"until,omitempty"`

	// A JSON encoded value of filters (a `map[string][]string`) to process on the event list. Available filters:
	//
	// - `config=<string>` config name or ID
	// - `container=<string>` container name or ID
	// - `daemon=<string>` daemon name or ID
	// - `event=<string>` event type
	// - `image=<string>` image name or ID
	// - `label=<string>` image or container label
	// - `network=<string>` network name or ID
	// - `node=<string>` node ID
	// - `plugin`=<string> plugin name or ID
	// - `scope`=<string> local or swarm
	// - `secret=<string>` secret name or ID
	// - `service=<string>` service name or ID
	// - `type=<string>` object to filter by, one of `container`, `image`, `volume`, `network`, `daemon`, `plugin`, `node`, `service`, `secret` or `config`
	// - `volume=<string>` volume name
	Filters *string `json:"filters,omitempty"`
}

// ExecResizeParams defines parameters for ExecResize.
type ExecResizeParams struct {
	// Height of the TTY session in characters
	H *int `json:"h,omitempty"`

	// Width of the TTY session in characters
	W *int `json:"w,omitempty"`
}

// ExecStartJSONBody defines parameters for ExecStart.
type ExecStartJSONBody struct {
	// Detach from the command.
	Detach *bool `json:"Detach,omitempty"`

	// Allocate a pseudo-TTY.
	Tty *bool `json:"Tty,omitempty"`
}

// ImageCreateParams defines parameters for ImageCreate.
type ImageCreateParams struct {
	// Name of the image to pull. The name may include a tag or digest. This parameter may only be used when pulling an image. The pull is cancelled if the HTTP connection is closed.
	FromImage *string `json:"fromImage,omitempty"`

	// Source to import. The value may be a URL from which the image can be retrieved or `-` to read the image from the request body. This parameter may only be used when importing an image.
	FromSrc *string `json:"fromSrc,omitempty"`

	// Repository name given to an image when it is imported. The repo may include a tag. This parameter may only be used when importing an image.
	Repo *string `json:"repo,omitempty"`

	// Tag or digest. If empty when pulling an image, this causes all tags for the given image to be pulled.
	Tag *string `json:"tag,omitempty"`

	// Set commit message for imported image.
	Message *string `json:"message,omitempty"`

	// Platform in the format os[/arch[/variant]]
	Platform *string `json:"platform,omitempty"`

	// A base64url-encoded auth configuration.
	//
	// Refer to the [authentication section](#section/Authentication) for
	// details.
	XRegistryAuth *string `json:"X-Registry-Auth,omitempty"`
}

// ImageGetAllParams defines parameters for ImageGetAll.
type ImageGetAllParams struct {
	// Image names to filter by
	Names *[]string `json:"names,omitempty"`
}

// ImageListParams defines parameters for ImageList.
type ImageListParams struct {
	// Show all images. Only images from a final layer (no children) are shown by default.
	All *bool `json:"all,omitempty"`

	// A JSON encoded value of the filters (a `map[string][]string`) to
	// process on the images list.
	//
	// Available filters:
	//
	// - `before`=(`<image-name>[:<tag>]`,  `<image id>` or `<image@digest>`)
	// - `dangling=true`
	// - `label=key` or `label="key=value"` of an image label
	// - `reference`=(`<image-name>[:<tag>]`)
	// - `since`=(`<image-name>[:<tag>]`,  `<image id>` or `<image@digest>`)
	Filters *string `json:"filters,omitempty"`

	// Show digest information as a `RepoDigests` field on each image.
	Digests *bool `json:"digests,omitempty"`
}

// ImageLoadParams defines parameters for ImageLoad.
type ImageLoadParams struct {
	// Suppress progress details during load.
	Quiet *bool `json:"quiet,omitempty"`
}

// ImagePruneParams defines parameters for ImagePrune.
type ImagePruneParams struct {
	// Filters to process on the prune list, encoded as JSON (a `map[string][]string`). Available filters:
	//
	// - `dangling=<boolean>` When set to `true` (or `1`), prune only
	//    unused *and* untagged images. When set to `false`
	//    (or `0`), all unused images are pruned.
	// - `until=<string>` Prune images created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machines time.
	// - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune images with (or without, in case `label!=...` is used) the specified labels.
	Filters *string `json:"filters,omitempty"`
}

// ImageSearchParams defines parameters for ImageSearch.
type ImageSearchParams struct {
	// Term to search
	Term string `json:"term"`

	// Maximum number of results to return
	Limit *int `json:"limit,omitempty"`

	// A JSON encoded value of the filters (a `map[string][]string`) to process on the images list. Available filters:
	//
	// - `is-automated=(true|false)`
	// - `is-official=(true|false)`
	// - `stars=<number>` Matches images that has at least 'number' stars.
	Filters *string `json:"filters,omitempty"`
}

// ImageDeleteParams defines parameters for ImageDelete.
type ImageDeleteParams struct {
	// Remove the image even if it is being used by stopped containers or has other tags
	Force *bool `json:"force,omitempty"`

	// Do not delete untagged parent images
	Noprune *bool `json:"noprune,omitempty"`
}

// ImagePushParams defines parameters for ImagePush.
type ImagePushParams struct {
	// The tag to associate with the image on the registry.
	Tag *string `json:"tag,omitempty"`

	// A base64url-encoded auth configuration.
	//
	// Refer to the [authentication section](#section/Authentication) for
	// details.
	XRegistryAuth string `json:"X-Registry-Auth"`
}

// ImageTagParams defines parameters for ImageTag.
type ImageTagParams struct {
	// The repository to tag in. For example, `someuser/someimage`.
	Repo *string `json:"repo,omitempty"`

	// The name of the new tag.
	Tag *string `json:"tag,omitempty"`
}

// NetworkListParams defines parameters for NetworkList.
type NetworkListParams struct {
	// JSON encoded value of the filters (a `map[string][]string`) to process
	// on the networks list.
	//
	// Available filters:
	//
	// - `dangling=<boolean>` When set to `true` (or `1`), returns all
	//    networks that are not in use by a container. When set to `false`
	//    (or `0`), only networks that are in use by one or more
	//    containers are returned.
	// - `driver=<driver-name>` Matches a network's driver.
	// - `id=<network-id>` Matches all or part of a network ID.
	// - `label=<key>` or `label=<key>=<value>` of a network label.
	// - `name=<network-name>` Matches all or part of a network name.
	// - `scope=["swarm"|"global"|"local"]` Filters networks by scope (`swarm`, `global`, or `local`).
	// - `type=["custom"|"builtin"]` Filters networks by type. The `custom` keyword returns all user-defined networks.
	Filters *string `json:"filters,omitempty"`
}

// NetworkCreateJSONBody defines parameters for NetworkCreate.
type NetworkCreateJSONBody struct {
	// Globally scoped network is manually attachable by regular
	// containers from workers in swarm mode.
	Attachable *bool `json:"Attachable,omitempty"`

	// Check for networks with duplicate names. Since Network is
	// primarily keyed based on a random ID and not on the name, and
	// network name is strictly a user-friendly alias to the network
	// which is uniquely identified using ID, there is no guaranteed
	// way to check for duplicates. CheckDuplicate is there to provide
	// a best effort checking of any networks which has the same name
	// but it is not guaranteed to catch all name collisions.
	CheckDuplicate *bool `json:"CheckDuplicate,omitempty"`

	// Name of the network driver plugin to use.
	Driver *string `json:"Driver,omitempty"`

	// Enable IPv6 on the network.
	EnableIPv6 *bool `json:"EnableIPv6,omitempty"`
	IPAM       *IPAM `json:"IPAM,omitempty"`

	// Ingress network is the network which provides the routing-mesh
	// in swarm mode.
	Ingress *bool `json:"Ingress,omitempty"`

	// Restrict external access to the network.
	Internal *bool `json:"Internal,omitempty"`

	// User-defined key/value metadata.
	Labels *NetworkCreateJSONBody_Labels `json:"Labels,omitempty"`

	// The network's name.
	Name string `json:"Name"`

	// Network specific options to be used by the drivers.
	Options *NetworkCreateJSONBody_Options `json:"Options,omitempty"`
}

// NetworkCreateJSONBody_Labels defines parameters for NetworkCreate.
type NetworkCreateJSONBody_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// NetworkCreateJSONBody_Options defines parameters for NetworkCreate.
type NetworkCreateJSONBody_Options struct {
	AdditionalProperties map[string]string `json:"-"`
}

// NetworkPruneParams defines parameters for NetworkPrune.
type NetworkPruneParams struct {
	// Filters to process on the prune list, encoded as JSON (a `map[string][]string`).
	//
	// Available filters:
	// - `until=<timestamp>` Prune networks created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machines time.
	// - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune networks with (or without, in case `label!=...` is used) the specified labels.
	Filters *string `json:"filters,omitempty"`
}

// NetworkInspectParams defines parameters for NetworkInspect.
type NetworkInspectParams struct {
	// Detailed inspect output for troubleshooting
	Verbose *bool `json:"verbose,omitempty"`

	// Filter the network by scope (swarm, global, or local)
	Scope *string `json:"scope,omitempty"`
}

// NetworkConnectJSONBody defines parameters for NetworkConnect.
type NetworkConnectJSONBody struct {
	// The ID or name of the container to connect to the network.
	Container *string `json:"Container,omitempty"`

	// Configuration for a network endpoint.
	EndpointConfig *EndpointSettings `json:"EndpointConfig,omitempty"`
}

// NetworkDisconnectJSONBody defines parameters for NetworkDisconnect.
type NetworkDisconnectJSONBody struct {
	// The ID or name of the container to disconnect from the network.
	Container *string `json:"Container,omitempty"`

	// Force the container to disconnect from the network.
	Force *bool `json:"Force,omitempty"`
}

// NodeListParams defines parameters for NodeList.
type NodeListParams struct {
	// Filters to process on the nodes list, encoded as JSON (a `map[string][]string`).
	//
	// Available filters:
	// - `id=<node id>`
	// - `label=<engine label>`
	// - `membership=`(`accepted`|`pending`)`
	// - `name=<node name>`
	// - `node.label=<node label>`
	// - `role=`(`manager`|`worker`)`
	Filters *string `json:"filters,omitempty"`
}

// NodeDeleteParams defines parameters for NodeDelete.
type NodeDeleteParams struct {
	// Force remove a node from the swarm
	Force *bool `json:"force,omitempty"`
}

// NodeUpdateJSONBody defines parameters for NodeUpdate.
type NodeUpdateJSONBody NodeSpec

// NodeUpdateParams defines parameters for NodeUpdate.
type NodeUpdateParams struct {
	// The version number of the node object being updated. This is required
	// to avoid conflicting writes.
	Version int64 `json:"version"`
}

// PluginListParams defines parameters for PluginList.
type PluginListParams struct {
	// A JSON encoded value of the filters (a `map[string][]string`) to
	// process on the plugin list.
	//
	// Available filters:
	//
	// - `capability=<capability name>`
	// - `enable=<true>|<false>`
	Filters *string `json:"filters,omitempty"`
}

// PluginCreateParams defines parameters for PluginCreate.
type PluginCreateParams struct {
	// The name of the plugin. The `:latest` tag is optional, and is the
	// default if omitted.
	Name string `json:"name"`
}

// GetPluginPrivilegesParams defines parameters for GetPluginPrivileges.
type GetPluginPrivilegesParams struct {
	// The name of the plugin. The `:latest` tag is optional, and is the
	// default if omitted.
	Remote string `json:"remote"`
}

// PluginPullJSONBody defines parameters for PluginPull.
type PluginPullJSONBody []struct {
	Description *string   `json:"Description,omitempty"`
	Name        *string   `json:"Name,omitempty"`
	Value       *[]string `json:"Value,omitempty"`
}

// PluginPullParams defines parameters for PluginPull.
type PluginPullParams struct {
	// Remote reference for plugin to install.
	//
	// The `:latest` tag is optional, and is used as the default if omitted.
	Remote string `json:"remote"`

	// Local name for the pulled plugin.
	//
	// The `:latest` tag is optional, and is used as the default if omitted.
	Name *string `json:"name,omitempty"`

	// A base64url-encoded auth configuration to use when pulling a plugin
	// from a registry.
	//
	// Refer to the [authentication section](#section/Authentication) for
	// details.
	XRegistryAuth *string `json:"X-Registry-Auth,omitempty"`
}

// PluginDeleteParams defines parameters for PluginDelete.
type PluginDeleteParams struct {
	// Disable the plugin before removing. This may result in issues if the
	// plugin is in use by a container.
	Force *bool `json:"force,omitempty"`
}

// PluginEnableParams defines parameters for PluginEnable.
type PluginEnableParams struct {
	// Set the HTTP client timeout (in seconds)
	Timeout *int `json:"timeout,omitempty"`
}

// PluginSetJSONBody defines parameters for PluginSet.
type PluginSetJSONBody []string

// PluginUpgradeJSONBody defines parameters for PluginUpgrade.
type PluginUpgradeJSONBody []struct {
	Description *string   `json:"Description,omitempty"`
	Name        *string   `json:"Name,omitempty"`
	Value       *[]string `json:"Value,omitempty"`
}

// PluginUpgradeParams defines parameters for PluginUpgrade.
type PluginUpgradeParams struct {
	// Remote reference to upgrade to.
	//
	// The `:latest` tag is optional, and is used as the default if omitted.
	Remote string `json:"remote"`

	// A base64url-encoded auth configuration to use when pulling a plugin
	// from a registry.
	//
	// Refer to the [authentication section](#section/Authentication) for
	// details.
	XRegistryAuth *string `json:"X-Registry-Auth,omitempty"`
}

// SecretListParams defines parameters for SecretList.
type SecretListParams struct {
	// A JSON encoded value of the filters (a `map[string][]string`) to
	// process on the secrets list.
	//
	// Available filters:
	//
	// - `id=<secret id>`
	// - `label=<key> or label=<key>=value`
	// - `name=<secret name>`
	// - `names=<secret name>`
	Filters *string `json:"filters,omitempty"`
}

// SecretCreateJSONBody defines parameters for SecretCreate.
type SecretCreateJSONBody struct {
	// Embedded struct due to allOf(#/components/schemas/SecretSpec)
	SecretSpec `yaml:",inline"`
	// Embedded fields due to inline allOf schema
}

// SecretUpdateJSONBody defines parameters for SecretUpdate.
type SecretUpdateJSONBody SecretSpec

// SecretUpdateParams defines parameters for SecretUpdate.
type SecretUpdateParams struct {
	// The version number of the secret object being updated. This is
	// required to avoid conflicting writes.
	Version int64 `json:"version"`
}

// ServiceListParams defines parameters for ServiceList.
type ServiceListParams struct {
	// A JSON encoded value of the filters (a `map[string][]string`) to
	// process on the services list.
	//
	// Available filters:
	//
	// - `id=<service id>`
	// - `label=<service label>`
	// - `mode=["replicated"|"global"]`
	// - `name=<service name>`
	Filters *string `json:"filters,omitempty"`

	// Include service status, with count of running and desired tasks.
	Status *bool `json:"status,omitempty"`
}

// ServiceCreateJSONBody defines parameters for ServiceCreate.
type ServiceCreateJSONBody struct {
	// Embedded struct due to allOf(#/components/schemas/ServiceSpec)
	ServiceSpec `yaml:",inline"`
	// Embedded fields due to inline allOf schema
}

// ServiceCreateParams defines parameters for ServiceCreate.
type ServiceCreateParams struct {
	// A base64url-encoded auth configuration for pulling from private
	// registries.
	//
	// Refer to the [authentication section](#section/Authentication) for
	// details.
	XRegistryAuth *string `json:"X-Registry-Auth,omitempty"`
}

// ServiceInspectParams defines parameters for ServiceInspect.
type ServiceInspectParams struct {
	// Fill empty fields with default values.
	InsertDefaults *bool `json:"insertDefaults,omitempty"`
}

// ServiceLogsParams defines parameters for ServiceLogs.
type ServiceLogsParams struct {
	// Show service context and extra details provided to logs.
	Details *bool `json:"details,omitempty"`

	// Keep connection after returning logs.
	Follow *bool `json:"follow,omitempty"`

	// Return logs from `stdout`
	Stdout *bool `json:"stdout,omitempty"`

	// Return logs from `stderr`
	Stderr *bool `json:"stderr,omitempty"`

	// Only return logs since this time, as a UNIX timestamp
	Since *int `json:"since,omitempty"`

	// Add timestamps to every log line
	Timestamps *bool `json:"timestamps,omitempty"`

	// Only return this number of log lines from the end of the logs.
	// Specify as an integer or `all` to output all log lines.
	Tail *string `json:"tail,omitempty"`
}

// ServiceUpdateJSONBody defines parameters for ServiceUpdate.
type ServiceUpdateJSONBody struct {
	// Embedded struct due to allOf(#/components/schemas/ServiceSpec)
	ServiceSpec `yaml:",inline"`
	// Embedded fields due to inline allOf schema
}

// ServiceUpdateParams defines parameters for ServiceUpdate.
type ServiceUpdateParams struct {
	// The version number of the service object being updated. This is
	// required to avoid conflicting writes.
	// This version number should be the value as currently set on the
	// service *before* the update. You can find the current version by
	// calling `GET /services/{id}`
	Version int `json:"version"`

	// If the `X-Registry-Auth` header is not specified, this parameter
	// indicates where to find registry authorization credentials.
	RegistryAuthFrom *ServiceUpdateParamsRegistryAuthFrom `json:"registryAuthFrom,omitempty"`

	// Set to this parameter to `previous` to cause a server-side rollback
	// to the previous service spec. The supplied spec will be ignored in
	// this case.
	Rollback *string `json:"rollback,omitempty"`

	// A base64url-encoded auth configuration for pulling from private
	// registries.
	//
	// Refer to the [authentication section](#section/Authentication) for
	// details.
	XRegistryAuth *string `json:"X-Registry-Auth,omitempty"`
}

// ServiceUpdateParamsRegistryAuthFrom defines parameters for ServiceUpdate.
type ServiceUpdateParamsRegistryAuthFrom string

// SwarmInitJSONBody defines parameters for SwarmInit.
type SwarmInitJSONBody struct {
	// Externally reachable address advertised to other nodes. This
	// can either be an address/port combination in the form
	// `192.168.1.1:4567`, or an interface followed by a port number,
	// like `eth0:4567`. If the port number is omitted, the port
	// number from the listen address is used. If `AdvertiseAddr` is
	// not specified, it will be automatically detected when possible.
	AdvertiseAddr *string `json:"AdvertiseAddr,omitempty"`

	// Address or interface to use for data path traffic (format:
	// `<ip|interface>`), for example,  `192.168.1.1`, or an interface,
	// like `eth0`. If `DataPathAddr` is unspecified, the same address
	// as `AdvertiseAddr` is used.
	//
	// The `DataPathAddr` specifies the address that global scope
	// network drivers will publish towards other  nodes in order to
	// reach the containers running on this node. Using this parameter
	// it is possible to separate the container data traffic from the
	// management traffic of the cluster.
	DataPathAddr *string `json:"DataPathAddr,omitempty"`

	// DataPathPort specifies the data path port number for data traffic.
	// Acceptable port range is 1024 to 49151.
	// if no port is set or is set to 0, default port 4789 will be used.
	DataPathPort *uint32 `json:"DataPathPort,omitempty"`

	// Default Address Pool specifies default subnet pools for global
	// scope networks.
	DefaultAddrPool *[]string `json:"DefaultAddrPool,omitempty"`

	// Force creation of a new swarm.
	ForceNewCluster *bool `json:"ForceNewCluster,omitempty"`

	// Listen address used for inter-manager communication, as well
	// as determining the networking interface used for the VXLAN
	// Tunnel Endpoint (VTEP). This can either be an address/port
	// combination in the form `192.168.1.1:4567`, or an interface
	// followed by a port number, like `eth0:4567`. If the port number
	// is omitted, the default swarm listening port is used.
	ListenAddr *string `json:"ListenAddr,omitempty"`

	// User modifiable swarm configuration.
	Spec *SwarmSpec `json:"Spec,omitempty"`

	// SubnetSize specifies the subnet size of the networks created
	// from the default subnet pool.
	SubnetSize *uint32 `json:"SubnetSize,omitempty"`
}

// SwarmJoinJSONBody defines parameters for SwarmJoin.
type SwarmJoinJSONBody struct {
	// Externally reachable address advertised to other nodes. This
	// can either be an address/port combination in the form
	// `192.168.1.1:4567`, or an interface followed by a port number,
	// like `eth0:4567`. If the port number is omitted, the port
	// number from the listen address is used. If `AdvertiseAddr` is
	// not specified, it will be automatically detected when possible.
	AdvertiseAddr *string `json:"AdvertiseAddr,omitempty"`

	// Address or interface to use for data path traffic (format:
	// `<ip|interface>`), for example,  `192.168.1.1`, or an interface,
	// like `eth0`. If `DataPathAddr` is unspecified, the same addres
	// as `AdvertiseAddr` is used.
	//
	// The `DataPathAddr` specifies the address that global scope
	// network drivers will publish towards other nodes in order to
	// reach the containers running on this node. Using this parameter
	// it is possible to separate the container data traffic from the
	// management traffic of the cluster.
	DataPathAddr *string `json:"DataPathAddr,omitempty"`

	// Secret token for joining this swarm.
	JoinToken *string `json:"JoinToken,omitempty"`

	// Listen address used for inter-manager communication if the node
	// gets promoted to manager, as well as determining the networking
	// interface used for the VXLAN Tunnel Endpoint (VTEP).
	ListenAddr *string `json:"ListenAddr,omitempty"`

	// Addresses of manager nodes already participating in the swarm.
	RemoteAddrs *[]string `json:"RemoteAddrs,omitempty"`
}

// SwarmLeaveParams defines parameters for SwarmLeave.
type SwarmLeaveParams struct {
	// Force leave swarm, even if this is the last manager or that it will
	// break the cluster.
	Force *bool `json:"force,omitempty"`
}

// SwarmUnlockJSONBody defines parameters for SwarmUnlock.
type SwarmUnlockJSONBody struct {
	// The swarm's unlock key.
	UnlockKey *string `json:"UnlockKey,omitempty"`
}

// SwarmUpdateJSONBody defines parameters for SwarmUpdate.
type SwarmUpdateJSONBody SwarmSpec

// SwarmUpdateParams defines parameters for SwarmUpdate.
type SwarmUpdateParams struct {
	// The version number of the swarm object being updated. This is
	// required to avoid conflicting writes.
	Version int64 `json:"version"`

	// Rotate the worker join token.
	RotateWorkerToken *bool `json:"rotateWorkerToken,omitempty"`

	// Rotate the manager join token.
	RotateManagerToken *bool `json:"rotateManagerToken,omitempty"`

	// Rotate the manager unlock key.
	RotateManagerUnlockKey *bool `json:"rotateManagerUnlockKey,omitempty"`
}

// TaskListParams defines parameters for TaskList.
type TaskListParams struct {
	// A JSON encoded value of the filters (a `map[string][]string`) to
	// process on the tasks list.
	//
	// Available filters:
	//
	// - `desired-state=(running | shutdown | accepted)`
	// - `id=<task id>`
	// - `label=key` or `label="key=value"`
	// - `name=<task name>`
	// - `node=<node id or name>`
	// - `service=<service name>`
	Filters *string `json:"filters,omitempty"`
}

// TaskLogsParams defines parameters for TaskLogs.
type TaskLogsParams struct {
	// Show task context and extra details provided to logs.
	Details *bool `json:"details,omitempty"`

	// Keep connection after returning logs.
	Follow *bool `json:"follow,omitempty"`

	// Return logs from `stdout`
	Stdout *bool `json:"stdout,omitempty"`

	// Return logs from `stderr`
	Stderr *bool `json:"stderr,omitempty"`

	// Only return logs since this time, as a UNIX timestamp
	Since *int `json:"since,omitempty"`

	// Add timestamps to every log line
	Timestamps *bool `json:"timestamps,omitempty"`

	// Only return this number of log lines from the end of the logs.
	// Specify as an integer or `all` to output all log lines.
	Tail *string `json:"tail,omitempty"`
}

// VolumeListParams defines parameters for VolumeList.
type VolumeListParams struct {
	// JSON encoded value of the filters (a `map[string][]string`) to
	// process on the volumes list. Available filters:
	//
	// - `dangling=<boolean>` When set to `true` (or `1`), returns all
	//    volumes that are not in use by a container. When set to `false`
	//    (or `0`), only volumes that are in use by one or more
	//    containers are returned.
	// - `driver=<volume-driver-name>` Matches volumes based on their driver.
	// - `label=<key>` or `label=<key>:<value>` Matches volumes based on
	//    the presence of a `label` alone or a `label` and a value.
	// - `name=<volume-name>` Matches all or part of a volume name.
	Filters json.RawMessage `json:"filters,omitempty"`
}

// VolumeCreateJSONBody defines parameters for VolumeCreate.
type VolumeCreateJSONBody struct {
	// Name of the volume driver to use.
	Driver *string `json:"Driver,omitempty"`

	// A mapping of driver options and values. These options are
	// passed directly to the driver and are driver specific.
	DriverOpts *VolumeCreateJSONBody_DriverOpts `json:"DriverOpts,omitempty"`

	// User-defined key/value metadata.
	Labels *VolumeCreateJSONBody_Labels `json:"Labels,omitempty"`

	// The new volume's name. If not specified, Docker generates a name.
	Name *string `json:"Name,omitempty"`
}

// VolumeCreateJSONBody_DriverOpts defines parameters for VolumeCreate.
type VolumeCreateJSONBody_DriverOpts struct {
	AdditionalProperties map[string]string `json:"-"`
}

// VolumeCreateJSONBody_Labels defines parameters for VolumeCreate.
type VolumeCreateJSONBody_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// VolumePruneParams defines parameters for VolumePrune.
type VolumePruneParams struct {
	// Filters to process on the prune list, encoded as JSON (a `map[string][]string`).
	//
	// Available filters:
	// - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune volumes with (or without, in case `label!=...` is used) the specified labels.
	Filters *string `json:"filters,omitempty"`
}

// VolumeDeleteParams defines parameters for VolumeDelete.
type VolumeDeleteParams struct {
	// Force the removal of the volume
	Force *bool `json:"force,omitempty"`
}

// SystemAuthJSONRequestBody defines body for SystemAuth for application/json ContentType.
type SystemAuthJSONRequestBody SystemAuthJSONBody

// ImageCommitJSONRequestBody defines body for ImageCommit for application/json ContentType.
type ImageCommitJSONRequestBody ImageCommitJSONBody

// ConfigCreateJSONRequestBody defines body for ConfigCreate for application/json ContentType.
type ConfigCreateJSONRequestBody ConfigCreateJSONBody

// ConfigUpdateJSONRequestBody defines body for ConfigUpdate for application/json ContentType.
type ConfigUpdateJSONRequestBody ConfigUpdateJSONBody

// ContainerCreateJSONRequestBody defines body for ContainerCreate for application/json ContentType.
type ContainerCreateJSONRequestBody ContainerCreateJSONBody

// ContainerExecJSONRequestBody defines body for ContainerExec for application/json ContentType.
type ContainerExecJSONRequestBody ContainerExecJSONBody

// ContainerUpdateJSONRequestBody defines body for ContainerUpdate for application/json ContentType.
type ContainerUpdateJSONRequestBody ContainerUpdateJSONBody

// ExecStartJSONRequestBody defines body for ExecStart for application/json ContentType.
type ExecStartJSONRequestBody ExecStartJSONBody

// NetworkCreateJSONRequestBody defines body for NetworkCreate for application/json ContentType.
type NetworkCreateJSONRequestBody NetworkCreateJSONBody

// NetworkConnectJSONRequestBody defines body for NetworkConnect for application/json ContentType.
type NetworkConnectJSONRequestBody NetworkConnectJSONBody

// NetworkDisconnectJSONRequestBody defines body for NetworkDisconnect for application/json ContentType.
type NetworkDisconnectJSONRequestBody NetworkDisconnectJSONBody

// NodeUpdateJSONRequestBody defines body for NodeUpdate for application/json ContentType.
type NodeUpdateJSONRequestBody NodeUpdateJSONBody

// PluginPullJSONRequestBody defines body for PluginPull for application/json ContentType.
type PluginPullJSONRequestBody PluginPullJSONBody

// PluginSetJSONRequestBody defines body for PluginSet for application/json ContentType.
type PluginSetJSONRequestBody PluginSetJSONBody

// PluginUpgradeJSONRequestBody defines body for PluginUpgrade for application/json ContentType.
type PluginUpgradeJSONRequestBody PluginUpgradeJSONBody

// SecretCreateJSONRequestBody defines body for SecretCreate for application/json ContentType.
type SecretCreateJSONRequestBody SecretCreateJSONBody

// SecretUpdateJSONRequestBody defines body for SecretUpdate for application/json ContentType.
type SecretUpdateJSONRequestBody SecretUpdateJSONBody

// ServiceCreateJSONRequestBody defines body for ServiceCreate for application/json ContentType.
type ServiceCreateJSONRequestBody ServiceCreateJSONBody

// ServiceUpdateJSONRequestBody defines body for ServiceUpdate for application/json ContentType.
type ServiceUpdateJSONRequestBody ServiceUpdateJSONBody

// SwarmInitJSONRequestBody defines body for SwarmInit for application/json ContentType.
type SwarmInitJSONRequestBody SwarmInitJSONBody

// SwarmJoinJSONRequestBody defines body for SwarmJoin for application/json ContentType.
type SwarmJoinJSONRequestBody SwarmJoinJSONBody

// SwarmUnlockJSONRequestBody defines body for SwarmUnlock for application/json ContentType.
type SwarmUnlockJSONRequestBody SwarmUnlockJSONBody

// SwarmUpdateJSONRequestBody defines body for SwarmUpdate for application/json ContentType.
type SwarmUpdateJSONRequestBody SwarmUpdateJSONBody

// VolumeCreateJSONRequestBody defines body for VolumeCreate for application/json ContentType.
type VolumeCreateJSONRequestBody VolumeCreateJSONBody

// Getter for additional properties for NetworkCreateJSONBody_Labels. Returns the specified
// element and whether it was found
func (a NetworkCreateJSONBody_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NetworkCreateJSONBody_Labels
func (a *NetworkCreateJSONBody_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NetworkCreateJSONBody_Labels to handle AdditionalProperties
func (a *NetworkCreateJSONBody_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NetworkCreateJSONBody_Labels to handle AdditionalProperties
func (a NetworkCreateJSONBody_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NetworkCreateJSONBody_Options. Returns the specified
// element and whether it was found
func (a NetworkCreateJSONBody_Options) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NetworkCreateJSONBody_Options
func (a *NetworkCreateJSONBody_Options) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NetworkCreateJSONBody_Options to handle AdditionalProperties
func (a *NetworkCreateJSONBody_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NetworkCreateJSONBody_Options to handle AdditionalProperties
func (a NetworkCreateJSONBody_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for VolumeCreateJSONBody_DriverOpts. Returns the specified
// element and whether it was found
func (a VolumeCreateJSONBody_DriverOpts) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for VolumeCreateJSONBody_DriverOpts
func (a *VolumeCreateJSONBody_DriverOpts) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for VolumeCreateJSONBody_DriverOpts to handle AdditionalProperties
func (a *VolumeCreateJSONBody_DriverOpts) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for VolumeCreateJSONBody_DriverOpts to handle AdditionalProperties
func (a VolumeCreateJSONBody_DriverOpts) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for VolumeCreateJSONBody_Labels. Returns the specified
// element and whether it was found
func (a VolumeCreateJSONBody_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for VolumeCreateJSONBody_Labels
func (a *VolumeCreateJSONBody_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for VolumeCreateJSONBody_Labels to handle AdditionalProperties
func (a *VolumeCreateJSONBody_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for VolumeCreateJSONBody_Labels to handle AdditionalProperties
func (a VolumeCreateJSONBody_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ConfigSpec_Labels. Returns the specified
// element and whether it was found
func (a ConfigSpec_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ConfigSpec_Labels
func (a *ConfigSpec_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ConfigSpec_Labels to handle AdditionalProperties
func (a *ConfigSpec_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ConfigSpec_Labels to handle AdditionalProperties
func (a ConfigSpec_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ContainerConfig_ExposedPorts. Returns the specified
// element and whether it was found
func (a ContainerConfig_ExposedPorts) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ContainerConfig_ExposedPorts
func (a *ContainerConfig_ExposedPorts) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ContainerConfig_ExposedPorts to handle AdditionalProperties
func (a *ContainerConfig_ExposedPorts) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ContainerConfig_ExposedPorts to handle AdditionalProperties
func (a ContainerConfig_ExposedPorts) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ContainerConfig_Labels. Returns the specified
// element and whether it was found
func (a ContainerConfig_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ContainerConfig_Labels
func (a *ContainerConfig_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ContainerConfig_Labels to handle AdditionalProperties
func (a *ContainerConfig_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ContainerConfig_Labels to handle AdditionalProperties
func (a ContainerConfig_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ContainerConfig_Volumes. Returns the specified
// element and whether it was found
func (a ContainerConfig_Volumes) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ContainerConfig_Volumes
func (a *ContainerConfig_Volumes) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ContainerConfig_Volumes to handle AdditionalProperties
func (a *ContainerConfig_Volumes) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ContainerConfig_Volumes to handle AdditionalProperties
func (a ContainerConfig_Volumes) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ContainerSummary_Labels. Returns the specified
// element and whether it was found
func (a ContainerSummary_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ContainerSummary_Labels
func (a *ContainerSummary_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ContainerSummary_Labels to handle AdditionalProperties
func (a *ContainerSummary_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ContainerSummary_Labels to handle AdditionalProperties
func (a ContainerSummary_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ContainerSummary_NetworkSettings_Networks. Returns the specified
// element and whether it was found
func (a ContainerSummary_NetworkSettings_Networks) Get(fieldName string) (value EndpointSettings, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ContainerSummary_NetworkSettings_Networks
func (a *ContainerSummary_NetworkSettings_Networks) Set(fieldName string, value EndpointSettings) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]EndpointSettings)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ContainerSummary_NetworkSettings_Networks to handle AdditionalProperties
func (a *ContainerSummary_NetworkSettings_Networks) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]EndpointSettings)
		for fieldName, fieldBuf := range object {
			var fieldVal EndpointSettings
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ContainerSummary_NetworkSettings_Networks to handle AdditionalProperties
func (a ContainerSummary_NetworkSettings_Networks) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DeviceRequest_Options. Returns the specified
// element and whether it was found
func (a DeviceRequest_Options) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DeviceRequest_Options
func (a *DeviceRequest_Options) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DeviceRequest_Options to handle AdditionalProperties
func (a *DeviceRequest_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DeviceRequest_Options to handle AdditionalProperties
func (a DeviceRequest_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Driver_Options. Returns the specified
// element and whether it was found
func (a Driver_Options) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Driver_Options
func (a *Driver_Options) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Driver_Options to handle AdditionalProperties
func (a *Driver_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Driver_Options to handle AdditionalProperties
func (a Driver_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EndpointSettings_DriverOpts. Returns the specified
// element and whether it was found
func (a EndpointSettings_DriverOpts) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EndpointSettings_DriverOpts
func (a *EndpointSettings_DriverOpts) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EndpointSettings_DriverOpts to handle AdditionalProperties
func (a *EndpointSettings_DriverOpts) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EndpointSettings_DriverOpts to handle AdditionalProperties
func (a EndpointSettings_DriverOpts) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EngineDescription_Labels. Returns the specified
// element and whether it was found
func (a EngineDescription_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EngineDescription_Labels
func (a *EngineDescription_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EngineDescription_Labels to handle AdditionalProperties
func (a *EngineDescription_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EngineDescription_Labels to handle AdditionalProperties
func (a EngineDescription_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for GraphDriverData_Data. Returns the specified
// element and whether it was found
func (a GraphDriverData_Data) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GraphDriverData_Data
func (a *GraphDriverData_Data) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GraphDriverData_Data to handle AdditionalProperties
func (a *GraphDriverData_Data) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GraphDriverData_Data to handle AdditionalProperties
func (a GraphDriverData_Data) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for HostConfig_LogConfig_Config. Returns the specified
// element and whether it was found
func (a HostConfig_LogConfig_Config) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for HostConfig_LogConfig_Config
func (a *HostConfig_LogConfig_Config) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for HostConfig_LogConfig_Config to handle AdditionalProperties
func (a *HostConfig_LogConfig_Config) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for HostConfig_LogConfig_Config to handle AdditionalProperties
func (a HostConfig_LogConfig_Config) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for HostConfig_StorageOpt. Returns the specified
// element and whether it was found
func (a HostConfig_StorageOpt) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for HostConfig_StorageOpt
func (a *HostConfig_StorageOpt) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for HostConfig_StorageOpt to handle AdditionalProperties
func (a *HostConfig_StorageOpt) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for HostConfig_StorageOpt to handle AdditionalProperties
func (a HostConfig_StorageOpt) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for HostConfig_Sysctls. Returns the specified
// element and whether it was found
func (a HostConfig_Sysctls) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for HostConfig_Sysctls
func (a *HostConfig_Sysctls) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for HostConfig_Sysctls to handle AdditionalProperties
func (a *HostConfig_Sysctls) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for HostConfig_Sysctls to handle AdditionalProperties
func (a HostConfig_Sysctls) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for HostConfig_Tmpfs. Returns the specified
// element and whether it was found
func (a HostConfig_Tmpfs) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for HostConfig_Tmpfs
func (a *HostConfig_Tmpfs) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for HostConfig_Tmpfs to handle AdditionalProperties
func (a *HostConfig_Tmpfs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for HostConfig_Tmpfs to handle AdditionalProperties
func (a HostConfig_Tmpfs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IPAM_Options. Returns the specified
// element and whether it was found
func (a IPAM_Options) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IPAM_Options
func (a *IPAM_Options) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IPAM_Options to handle AdditionalProperties
func (a *IPAM_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IPAM_Options to handle AdditionalProperties
func (a IPAM_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ImageSummary_Labels. Returns the specified
// element and whether it was found
func (a ImageSummary_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ImageSummary_Labels
func (a *ImageSummary_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ImageSummary_Labels to handle AdditionalProperties
func (a *ImageSummary_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ImageSummary_Labels to handle AdditionalProperties
func (a ImageSummary_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Mount_VolumeOptions_DriverConfig_Options. Returns the specified
// element and whether it was found
func (a Mount_VolumeOptions_DriverConfig_Options) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Mount_VolumeOptions_DriverConfig_Options
func (a *Mount_VolumeOptions_DriverConfig_Options) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Mount_VolumeOptions_DriverConfig_Options to handle AdditionalProperties
func (a *Mount_VolumeOptions_DriverConfig_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Mount_VolumeOptions_DriverConfig_Options to handle AdditionalProperties
func (a Mount_VolumeOptions_DriverConfig_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Mount_VolumeOptions_Labels. Returns the specified
// element and whether it was found
func (a Mount_VolumeOptions_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Mount_VolumeOptions_Labels
func (a *Mount_VolumeOptions_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Mount_VolumeOptions_Labels to handle AdditionalProperties
func (a *Mount_VolumeOptions_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Mount_VolumeOptions_Labels to handle AdditionalProperties
func (a Mount_VolumeOptions_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Network_Containers. Returns the specified
// element and whether it was found
func (a Network_Containers) Get(fieldName string) (value NetworkContainer, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Network_Containers
func (a *Network_Containers) Set(fieldName string, value NetworkContainer) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]NetworkContainer)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Network_Containers to handle AdditionalProperties
func (a *Network_Containers) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]NetworkContainer)
		for fieldName, fieldBuf := range object {
			var fieldVal NetworkContainer
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Network_Containers to handle AdditionalProperties
func (a Network_Containers) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Network_Labels. Returns the specified
// element and whether it was found
func (a Network_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Network_Labels
func (a *Network_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Network_Labels to handle AdditionalProperties
func (a *Network_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Network_Labels to handle AdditionalProperties
func (a Network_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Network_Options. Returns the specified
// element and whether it was found
func (a Network_Options) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Network_Options
func (a *Network_Options) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Network_Options to handle AdditionalProperties
func (a *Network_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Network_Options to handle AdditionalProperties
func (a Network_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NetworkAttachmentConfig_DriverOpts. Returns the specified
// element and whether it was found
func (a NetworkAttachmentConfig_DriverOpts) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NetworkAttachmentConfig_DriverOpts
func (a *NetworkAttachmentConfig_DriverOpts) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NetworkAttachmentConfig_DriverOpts to handle AdditionalProperties
func (a *NetworkAttachmentConfig_DriverOpts) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NetworkAttachmentConfig_DriverOpts to handle AdditionalProperties
func (a NetworkAttachmentConfig_DriverOpts) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NetworkSettings_Networks. Returns the specified
// element and whether it was found
func (a NetworkSettings_Networks) Get(fieldName string) (value EndpointSettings, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NetworkSettings_Networks
func (a *NetworkSettings_Networks) Set(fieldName string, value EndpointSettings) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]EndpointSettings)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NetworkSettings_Networks to handle AdditionalProperties
func (a *NetworkSettings_Networks) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]EndpointSettings)
		for fieldName, fieldBuf := range object {
			var fieldVal EndpointSettings
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NetworkSettings_Networks to handle AdditionalProperties
func (a NetworkSettings_Networks) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NetworkingConfig_EndpointsConfig. Returns the specified
// element and whether it was found
func (a NetworkingConfig_EndpointsConfig) Get(fieldName string) (value EndpointSettings, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NetworkingConfig_EndpointsConfig
func (a *NetworkingConfig_EndpointsConfig) Set(fieldName string, value EndpointSettings) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]EndpointSettings)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NetworkingConfig_EndpointsConfig to handle AdditionalProperties
func (a *NetworkingConfig_EndpointsConfig) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]EndpointSettings)
		for fieldName, fieldBuf := range object {
			var fieldVal EndpointSettings
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NetworkingConfig_EndpointsConfig to handle AdditionalProperties
func (a NetworkingConfig_EndpointsConfig) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NodeSpec_Labels. Returns the specified
// element and whether it was found
func (a NodeSpec_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NodeSpec_Labels
func (a *NodeSpec_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NodeSpec_Labels to handle AdditionalProperties
func (a *NodeSpec_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NodeSpec_Labels to handle AdditionalProperties
func (a NodeSpec_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PortMap. Returns the specified
// element and whether it was found
func (a PortMap) Get(fieldName string) (value []PortBinding, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PortMap
func (a *PortMap) Set(fieldName string, value []PortBinding) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]PortBinding)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PortMap to handle AdditionalProperties
func (a *PortMap) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]PortBinding)
		for fieldName, fieldBuf := range object {
			var fieldVal []PortBinding
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PortMap to handle AdditionalProperties
func (a PortMap) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RegistryServiceConfig_IndexConfigs. Returns the specified
// element and whether it was found
func (a RegistryServiceConfig_IndexConfigs) Get(fieldName string) (value IndexInfo, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RegistryServiceConfig_IndexConfigs
func (a *RegistryServiceConfig_IndexConfigs) Set(fieldName string, value IndexInfo) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]IndexInfo)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RegistryServiceConfig_IndexConfigs to handle AdditionalProperties
func (a *RegistryServiceConfig_IndexConfigs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]IndexInfo)
		for fieldName, fieldBuf := range object {
			var fieldVal IndexInfo
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RegistryServiceConfig_IndexConfigs to handle AdditionalProperties
func (a RegistryServiceConfig_IndexConfigs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SecretSpec_Labels. Returns the specified
// element and whether it was found
func (a SecretSpec_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SecretSpec_Labels
func (a *SecretSpec_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SecretSpec_Labels to handle AdditionalProperties
func (a *SecretSpec_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SecretSpec_Labels to handle AdditionalProperties
func (a SecretSpec_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ServiceSpec_Labels. Returns the specified
// element and whether it was found
func (a ServiceSpec_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ServiceSpec_Labels
func (a *ServiceSpec_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ServiceSpec_Labels to handle AdditionalProperties
func (a *ServiceSpec_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ServiceSpec_Labels to handle AdditionalProperties
func (a ServiceSpec_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SwarmSpec_CAConfig_ExternalCAs_Options. Returns the specified
// element and whether it was found
func (a SwarmSpec_CAConfig_ExternalCAs_Options) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SwarmSpec_CAConfig_ExternalCAs_Options
func (a *SwarmSpec_CAConfig_ExternalCAs_Options) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SwarmSpec_CAConfig_ExternalCAs_Options to handle AdditionalProperties
func (a *SwarmSpec_CAConfig_ExternalCAs_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SwarmSpec_CAConfig_ExternalCAs_Options to handle AdditionalProperties
func (a SwarmSpec_CAConfig_ExternalCAs_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SwarmSpec_Labels. Returns the specified
// element and whether it was found
func (a SwarmSpec_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SwarmSpec_Labels
func (a *SwarmSpec_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SwarmSpec_Labels to handle AdditionalProperties
func (a *SwarmSpec_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SwarmSpec_Labels to handle AdditionalProperties
func (a SwarmSpec_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SwarmSpec_TaskDefaults_LogDriver_Options. Returns the specified
// element and whether it was found
func (a SwarmSpec_TaskDefaults_LogDriver_Options) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SwarmSpec_TaskDefaults_LogDriver_Options
func (a *SwarmSpec_TaskDefaults_LogDriver_Options) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SwarmSpec_TaskDefaults_LogDriver_Options to handle AdditionalProperties
func (a *SwarmSpec_TaskDefaults_LogDriver_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SwarmSpec_TaskDefaults_LogDriver_Options to handle AdditionalProperties
func (a SwarmSpec_TaskDefaults_LogDriver_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SystemInfo_Runtimes. Returns the specified
// element and whether it was found
func (a SystemInfo_Runtimes) Get(fieldName string) (value Runtime, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SystemInfo_Runtimes
func (a *SystemInfo_Runtimes) Set(fieldName string, value Runtime) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Runtime)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SystemInfo_Runtimes to handle AdditionalProperties
func (a *SystemInfo_Runtimes) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Runtime)
		for fieldName, fieldBuf := range object {
			var fieldVal Runtime
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SystemInfo_Runtimes to handle AdditionalProperties
func (a SystemInfo_Runtimes) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Task_Labels. Returns the specified
// element and whether it was found
func (a Task_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Task_Labels
func (a *Task_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Task_Labels to handle AdditionalProperties
func (a *Task_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Task_Labels to handle AdditionalProperties
func (a Task_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TaskSpec_ContainerSpec_Labels. Returns the specified
// element and whether it was found
func (a TaskSpec_ContainerSpec_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TaskSpec_ContainerSpec_Labels
func (a *TaskSpec_ContainerSpec_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TaskSpec_ContainerSpec_Labels to handle AdditionalProperties
func (a *TaskSpec_ContainerSpec_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TaskSpec_ContainerSpec_Labels to handle AdditionalProperties
func (a TaskSpec_ContainerSpec_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TaskSpec_ContainerSpec_Sysctls. Returns the specified
// element and whether it was found
func (a TaskSpec_ContainerSpec_Sysctls) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TaskSpec_ContainerSpec_Sysctls
func (a *TaskSpec_ContainerSpec_Sysctls) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TaskSpec_ContainerSpec_Sysctls to handle AdditionalProperties
func (a *TaskSpec_ContainerSpec_Sysctls) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TaskSpec_ContainerSpec_Sysctls to handle AdditionalProperties
func (a TaskSpec_ContainerSpec_Sysctls) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TaskSpec_LogDriver_Options. Returns the specified
// element and whether it was found
func (a TaskSpec_LogDriver_Options) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TaskSpec_LogDriver_Options
func (a *TaskSpec_LogDriver_Options) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TaskSpec_LogDriver_Options to handle AdditionalProperties
func (a *TaskSpec_LogDriver_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TaskSpec_LogDriver_Options to handle AdditionalProperties
func (a TaskSpec_LogDriver_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Volume_Labels. Returns the specified
// element and whether it was found
func (a Volume_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Volume_Labels
func (a *Volume_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Volume_Labels to handle AdditionalProperties
func (a *Volume_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Volume_Labels to handle AdditionalProperties
func (a Volume_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Volume_Options. Returns the specified
// element and whether it was found
func (a Volume_Options) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Volume_Options
func (a *Volume_Options) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Volume_Options to handle AdditionalProperties
func (a *Volume_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Volume_Options to handle AdditionalProperties
func (a Volume_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Volume_Status. Returns the specified
// element and whether it was found
func (a Volume_Status) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Volume_Status
func (a *Volume_Status) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Volume_Status to handle AdditionalProperties
func (a *Volume_Status) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Volume_Status to handle AdditionalProperties
func (a Volume_Status) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

