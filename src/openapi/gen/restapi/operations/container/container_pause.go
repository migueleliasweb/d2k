// Code generated by go-swagger; DO NOT EDIT.

package container

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	"github.com/go-openapi/runtime/middleware"
)

// ContainerPauseHandlerFunc turns a function with the right signature into a container pause handler
type ContainerPauseHandlerFunc func(ContainerPauseParams) middleware.Responder

// Handle executing the request and returning a response
func (fn ContainerPauseHandlerFunc) Handle(params ContainerPauseParams) middleware.Responder {
	return fn(params)
}

// ContainerPauseHandler interface for that can handle valid container pause params
type ContainerPauseHandler interface {
	Handle(ContainerPauseParams) middleware.Responder
}

// NewContainerPause creates a new http.Handler for the container pause operation
func NewContainerPause(ctx *middleware.Context, handler ContainerPauseHandler) *ContainerPause {
	return &ContainerPause{Context: ctx, Handler: handler}
}

/* ContainerPause swagger:route POST /containers/{id}/pause Container containerPause

Pause a container

Use the freezer cgroup to suspend all processes in a container.

Traditionally, when suspending a process the `SIGSTOP` signal is used,
which is observable by the process being suspended. With the freezer
cgroup the process is unaware, and unable to capture, that it is being
suspended, and subsequently resumed.


*/
type ContainerPause struct {
	Context *middleware.Context
	Handler ContainerPauseHandler
}

func (o *ContainerPause) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		*r = *rCtx
	}
	var Params = NewContainerPauseParams()
	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params) // actually handle the request
	o.Context.Respond(rw, r, route.Produces, route, res)

}
