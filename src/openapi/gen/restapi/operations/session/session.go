// Code generated by go-swagger; DO NOT EDIT.

package session

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	"github.com/go-openapi/runtime/middleware"
)

// SessionHandlerFunc turns a function with the right signature into a session handler
type SessionHandlerFunc func(SessionParams) middleware.Responder

// Handle executing the request and returning a response
func (fn SessionHandlerFunc) Handle(params SessionParams) middleware.Responder {
	return fn(params)
}

// SessionHandler interface for that can handle valid session params
type SessionHandler interface {
	Handle(SessionParams) middleware.Responder
}

// NewSession creates a new http.Handler for the session operation
func NewSession(ctx *middleware.Context, handler SessionHandler) *Session {
	return &Session{Context: ctx, Handler: handler}
}

/* Session swagger:route POST /session Session session

Initialize interactive session

Start a new interactive session with a server. Session allows server to
call back to the client for advanced capabilities.

### Hijacking

This endpoint hijacks the HTTP connection to HTTP2 transport that allows
the client to expose gPRC services on that connection.

For example, the client sends this request to upgrade the connection:

```
POST /session HTTP/1.1
Upgrade: h2c
Connection: Upgrade
```

The Docker daemon responds with a `101 UPGRADED` response follow with
the raw stream:

```
HTTP/1.1 101 UPGRADED
Connection: Upgrade
Upgrade: h2c
```


*/
type Session struct {
	Context *middleware.Context
	Handler SessionHandler
}

func (o *Session) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		*r = *rCtx
	}
	var Params = NewSessionParams()
	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params) // actually handle the request
	o.Context.Respond(rw, r, route.Produces, route, res)

}
