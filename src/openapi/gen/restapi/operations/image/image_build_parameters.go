// Code generated by go-swagger; DO NOT EDIT.

package image

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"io"
	"net/http"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NewImageBuildParams creates a new ImageBuildParams object
// with the default values initialized.
func NewImageBuildParams() ImageBuildParams {

	var (
		// initialize parameters with default values

		contentTypeDefault = string("application/x-tar")

		dockerfileDefault = string("Dockerfile")

		forcermDefault = bool(false)

		nocacheDefault  = bool(false)
		outputsDefault  = string("")
		platformDefault = string("")

		qDefault = bool(false)

		rmDefault = bool(true)

		targetDefault = string("")
	)

	return ImageBuildParams{
		ContentType: &contentTypeDefault,

		Dockerfile: &dockerfileDefault,

		Forcerm: &forcermDefault,

		Nocache: &nocacheDefault,

		Outputs: &outputsDefault,

		Platform: &platformDefault,

		Q: &qDefault,

		Rm: &rmDefault,

		Target: &targetDefault,
	}
}

// ImageBuildParams contains all the bound params for the image build operation
// typically these are obtained from a http.Request
//
// swagger:parameters ImageBuild
type ImageBuildParams struct {

	// HTTP Request Object
	HTTPRequest *http.Request `json:"-"`

	/*
	  In: header
	  Default: "application/x-tar"
	*/
	ContentType *string
	/*This is a base64-encoded JSON object with auth configurations for multiple registries that a build may refer to.

	The key is a registry URL, and the value is an auth configuration object, [as described in the authentication section](#section/Authentication). For example:

	```
	{
	  "docker.example.com": {
	    "username": "janedoe",
	    "password": "hunter2"
	  },
	  "https://index.docker.io/v1/": {
	    "username": "mobydock",
	    "password": "conta1n3rize14"
	  }
	}
	```

	Only the registry domain name (and port if not the default 443) are required. However, for legacy reasons, the Docker Hub registry must be specified with both a `https://` prefix and a `/v1/` suffix even though Docker will prefer to use the v2 registry API.

	  In: header
	*/
	XRegistryConfig *string
	/*JSON map of string pairs for build-time variables. Users pass these values at build-time. Docker uses the buildargs as the environment context for commands run via the `Dockerfile` RUN instruction, or for variable expansion in other `Dockerfile` instructions. This is not meant for passing secret values.

	For example, the build arg `FOO=bar` would become `{"FOO":"bar"}` in JSON. This would result in the query parameter `buildargs={"FOO":"bar"}`. Note that `{"FOO":"bar"}` should be URI component encoded.

	[Read more about the buildargs instruction.](/engine/reference/builder/#arg)

	  In: query
	*/
	Buildargs *string
	/*JSON array of images used for build cache resolution.
	  In: query
	*/
	Cachefrom *string
	/*The length of a CPU period in microseconds.
	  In: query
	*/
	Cpuperiod *int64
	/*Microseconds of CPU time that the container can get in a CPU period.
	  In: query
	*/
	Cpuquota *int64
	/*CPUs in which to allow execution (e.g., `0-3`, `0,1`).
	  In: query
	*/
	Cpusetcpus *string
	/*CPU shares (relative weight).
	  In: query
	*/
	Cpushares *int64
	/*Path within the build context to the `Dockerfile`. This is ignored if `remote` is specified and points to an external `Dockerfile`.
	  In: query
	  Default: "Dockerfile"
	*/
	Dockerfile *string
	/*Extra hosts to add to /etc/hosts
	  In: query
	*/
	Extrahosts *string
	/*Always remove intermediate containers, even upon failure.
	  In: query
	  Default: false
	*/
	Forcerm *bool
	/*A tar archive compressed with one of the following algorithms: identity (no compression), gzip, bzip2, xz.
	  In: body
	*/
	InputStream io.ReadCloser
	/*Arbitrary key/value labels to set on the image, as a JSON map of string pairs.
	  In: query
	*/
	Labels *string
	/*Set memory limit for build.
	  In: query
	*/
	Memory *int64
	/*Total memory (memory + swap). Set as `-1` to disable swap.
	  In: query
	*/
	Memswap *int64
	/*Sets the networking mode for the run commands during build. Supported
	standard values are: `bridge`, `host`, `none`, and `container:<name|id>`.
	Any other value is taken as a custom network's name or ID to which this
	container should connect to.

	  In: query
	*/
	Networkmode *string
	/*Do not use the cache when building the image.
	  In: query
	  Default: false
	*/
	Nocache *bool
	/*BuildKit output configuration
	  In: query
	  Default: ""
	*/
	Outputs *string
	/*Platform in the format os[/arch[/variant]]
	  In: query
	  Default: ""
	*/
	Platform *string
	/*Attempt to pull the image even if an older image exists locally.
	  In: query
	*/
	Pull *string
	/*Suppress verbose build output.
	  In: query
	  Default: false
	*/
	Q *bool
	/*A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the fileâ€™s contents are placed into a file called `Dockerfile` and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the `dockerfile` parameter is also specified, there must be a file with the corresponding path inside the tarball.
	  In: query
	*/
	Remote *string
	/*Remove intermediate containers after a successful build.
	  In: query
	  Default: true
	*/
	Rm *bool
	/*Size of `/dev/shm` in bytes. The size must be greater than 0. If omitted the system uses 64MB.
	  In: query
	*/
	Shmsize *int64
	/*Squash the resulting images layers into a single layer. *(Experimental release only.)*
	  In: query
	*/
	Squash *bool
	/*A name and optional tag to apply to the image in the `name:tag` format. If you omit the tag the default `latest` value is assumed. You can provide several `t` parameters.
	  In: query
	*/
	T *string
	/*Target build stage
	  In: query
	  Default: ""
	*/
	Target *string
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls.
//
// To ensure default values, the struct must have been initialized with NewImageBuildParams() beforehand.
func (o *ImageBuildParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
	var res []error

	o.HTTPRequest = r

	qs := runtime.Values(r.URL.Query())

	if err := o.bindContentType(r.Header[http.CanonicalHeaderKey("Content-type")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	if err := o.bindXRegistryConfig(r.Header[http.CanonicalHeaderKey("X-Registry-Config")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	qBuildargs, qhkBuildargs, _ := qs.GetOK("buildargs")
	if err := o.bindBuildargs(qBuildargs, qhkBuildargs, route.Formats); err != nil {
		res = append(res, err)
	}

	qCachefrom, qhkCachefrom, _ := qs.GetOK("cachefrom")
	if err := o.bindCachefrom(qCachefrom, qhkCachefrom, route.Formats); err != nil {
		res = append(res, err)
	}

	qCpuperiod, qhkCpuperiod, _ := qs.GetOK("cpuperiod")
	if err := o.bindCpuperiod(qCpuperiod, qhkCpuperiod, route.Formats); err != nil {
		res = append(res, err)
	}

	qCpuquota, qhkCpuquota, _ := qs.GetOK("cpuquota")
	if err := o.bindCpuquota(qCpuquota, qhkCpuquota, route.Formats); err != nil {
		res = append(res, err)
	}

	qCpusetcpus, qhkCpusetcpus, _ := qs.GetOK("cpusetcpus")
	if err := o.bindCpusetcpus(qCpusetcpus, qhkCpusetcpus, route.Formats); err != nil {
		res = append(res, err)
	}

	qCpushares, qhkCpushares, _ := qs.GetOK("cpushares")
	if err := o.bindCpushares(qCpushares, qhkCpushares, route.Formats); err != nil {
		res = append(res, err)
	}

	qDockerfile, qhkDockerfile, _ := qs.GetOK("dockerfile")
	if err := o.bindDockerfile(qDockerfile, qhkDockerfile, route.Formats); err != nil {
		res = append(res, err)
	}

	qExtrahosts, qhkExtrahosts, _ := qs.GetOK("extrahosts")
	if err := o.bindExtrahosts(qExtrahosts, qhkExtrahosts, route.Formats); err != nil {
		res = append(res, err)
	}

	qForcerm, qhkForcerm, _ := qs.GetOK("forcerm")
	if err := o.bindForcerm(qForcerm, qhkForcerm, route.Formats); err != nil {
		res = append(res, err)
	}

	if runtime.HasBody(r) {
		o.InputStream = r.Body
	}

	qLabels, qhkLabels, _ := qs.GetOK("labels")
	if err := o.bindLabels(qLabels, qhkLabels, route.Formats); err != nil {
		res = append(res, err)
	}

	qMemory, qhkMemory, _ := qs.GetOK("memory")
	if err := o.bindMemory(qMemory, qhkMemory, route.Formats); err != nil {
		res = append(res, err)
	}

	qMemswap, qhkMemswap, _ := qs.GetOK("memswap")
	if err := o.bindMemswap(qMemswap, qhkMemswap, route.Formats); err != nil {
		res = append(res, err)
	}

	qNetworkmode, qhkNetworkmode, _ := qs.GetOK("networkmode")
	if err := o.bindNetworkmode(qNetworkmode, qhkNetworkmode, route.Formats); err != nil {
		res = append(res, err)
	}

	qNocache, qhkNocache, _ := qs.GetOK("nocache")
	if err := o.bindNocache(qNocache, qhkNocache, route.Formats); err != nil {
		res = append(res, err)
	}

	qOutputs, qhkOutputs, _ := qs.GetOK("outputs")
	if err := o.bindOutputs(qOutputs, qhkOutputs, route.Formats); err != nil {
		res = append(res, err)
	}

	qPlatform, qhkPlatform, _ := qs.GetOK("platform")
	if err := o.bindPlatform(qPlatform, qhkPlatform, route.Formats); err != nil {
		res = append(res, err)
	}

	qPull, qhkPull, _ := qs.GetOK("pull")
	if err := o.bindPull(qPull, qhkPull, route.Formats); err != nil {
		res = append(res, err)
	}

	qQ, qhkQ, _ := qs.GetOK("q")
	if err := o.bindQ(qQ, qhkQ, route.Formats); err != nil {
		res = append(res, err)
	}

	qRemote, qhkRemote, _ := qs.GetOK("remote")
	if err := o.bindRemote(qRemote, qhkRemote, route.Formats); err != nil {
		res = append(res, err)
	}

	qRm, qhkRm, _ := qs.GetOK("rm")
	if err := o.bindRm(qRm, qhkRm, route.Formats); err != nil {
		res = append(res, err)
	}

	qShmsize, qhkShmsize, _ := qs.GetOK("shmsize")
	if err := o.bindShmsize(qShmsize, qhkShmsize, route.Formats); err != nil {
		res = append(res, err)
	}

	qSquash, qhkSquash, _ := qs.GetOK("squash")
	if err := o.bindSquash(qSquash, qhkSquash, route.Formats); err != nil {
		res = append(res, err)
	}

	qT, qhkT, _ := qs.GetOK("t")
	if err := o.bindT(qT, qhkT, route.Formats); err != nil {
		res = append(res, err)
	}

	qTarget, qhkTarget, _ := qs.GetOK("target")
	if err := o.bindTarget(qTarget, qhkTarget, route.Formats); err != nil {
		res = append(res, err)
	}
	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// bindContentType binds and validates parameter ContentType from header.
func (o *ImageBuildParams) bindContentType(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false

	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewImageBuildParams()
		return nil
	}
	o.ContentType = &raw

	if err := o.validateContentType(formats); err != nil {
		return err
	}

	return nil
}

// validateContentType carries on validations for parameter ContentType
func (o *ImageBuildParams) validateContentType(formats strfmt.Registry) error {

	if err := validate.EnumCase("Content-type", "header", *o.ContentType, []interface{}{"application/x-tar"}, true); err != nil {
		return err
	}

	return nil
}

// bindXRegistryConfig binds and validates parameter XRegistryConfig from header.
func (o *ImageBuildParams) bindXRegistryConfig(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.XRegistryConfig = &raw

	return nil
}

// bindBuildargs binds and validates parameter Buildargs from query.
func (o *ImageBuildParams) bindBuildargs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.Buildargs = &raw

	return nil
}

// bindCachefrom binds and validates parameter Cachefrom from query.
func (o *ImageBuildParams) bindCachefrom(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.Cachefrom = &raw

	return nil
}

// bindCpuperiod binds and validates parameter Cpuperiod from query.
func (o *ImageBuildParams) bindCpuperiod(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("cpuperiod", "query", "int64", raw)
	}
	o.Cpuperiod = &value

	return nil
}

// bindCpuquota binds and validates parameter Cpuquota from query.
func (o *ImageBuildParams) bindCpuquota(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("cpuquota", "query", "int64", raw)
	}
	o.Cpuquota = &value

	return nil
}

// bindCpusetcpus binds and validates parameter Cpusetcpus from query.
func (o *ImageBuildParams) bindCpusetcpus(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.Cpusetcpus = &raw

	return nil
}

// bindCpushares binds and validates parameter Cpushares from query.
func (o *ImageBuildParams) bindCpushares(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("cpushares", "query", "int64", raw)
	}
	o.Cpushares = &value

	return nil
}

// bindDockerfile binds and validates parameter Dockerfile from query.
func (o *ImageBuildParams) bindDockerfile(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewImageBuildParams()
		return nil
	}
	o.Dockerfile = &raw

	return nil
}

// bindExtrahosts binds and validates parameter Extrahosts from query.
func (o *ImageBuildParams) bindExtrahosts(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.Extrahosts = &raw

	return nil
}

// bindForcerm binds and validates parameter Forcerm from query.
func (o *ImageBuildParams) bindForcerm(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewImageBuildParams()
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("forcerm", "query", "bool", raw)
	}
	o.Forcerm = &value

	return nil
}

// bindLabels binds and validates parameter Labels from query.
func (o *ImageBuildParams) bindLabels(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.Labels = &raw

	return nil
}

// bindMemory binds and validates parameter Memory from query.
func (o *ImageBuildParams) bindMemory(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("memory", "query", "int64", raw)
	}
	o.Memory = &value

	return nil
}

// bindMemswap binds and validates parameter Memswap from query.
func (o *ImageBuildParams) bindMemswap(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("memswap", "query", "int64", raw)
	}
	o.Memswap = &value

	return nil
}

// bindNetworkmode binds and validates parameter Networkmode from query.
func (o *ImageBuildParams) bindNetworkmode(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.Networkmode = &raw

	return nil
}

// bindNocache binds and validates parameter Nocache from query.
func (o *ImageBuildParams) bindNocache(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewImageBuildParams()
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("nocache", "query", "bool", raw)
	}
	o.Nocache = &value

	return nil
}

// bindOutputs binds and validates parameter Outputs from query.
func (o *ImageBuildParams) bindOutputs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewImageBuildParams()
		return nil
	}
	o.Outputs = &raw

	return nil
}

// bindPlatform binds and validates parameter Platform from query.
func (o *ImageBuildParams) bindPlatform(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewImageBuildParams()
		return nil
	}
	o.Platform = &raw

	return nil
}

// bindPull binds and validates parameter Pull from query.
func (o *ImageBuildParams) bindPull(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.Pull = &raw

	return nil
}

// bindQ binds and validates parameter Q from query.
func (o *ImageBuildParams) bindQ(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewImageBuildParams()
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("q", "query", "bool", raw)
	}
	o.Q = &value

	return nil
}

// bindRemote binds and validates parameter Remote from query.
func (o *ImageBuildParams) bindRemote(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.Remote = &raw

	return nil
}

// bindRm binds and validates parameter Rm from query.
func (o *ImageBuildParams) bindRm(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewImageBuildParams()
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("rm", "query", "bool", raw)
	}
	o.Rm = &value

	return nil
}

// bindShmsize binds and validates parameter Shmsize from query.
func (o *ImageBuildParams) bindShmsize(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("shmsize", "query", "int64", raw)
	}
	o.Shmsize = &value

	return nil
}

// bindSquash binds and validates parameter Squash from query.
func (o *ImageBuildParams) bindSquash(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("squash", "query", "bool", raw)
	}
	o.Squash = &value

	return nil
}

// bindT binds and validates parameter T from query.
func (o *ImageBuildParams) bindT(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.T = &raw

	return nil
}

// bindTarget binds and validates parameter Target from query.
func (o *ImageBuildParams) bindTarget(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewImageBuildParams()
		return nil
	}
	o.Target = &raw

	return nil
}
